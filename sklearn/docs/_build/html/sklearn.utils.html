

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sklearn.utils package &mdash; Qsklearn  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Qsklearn
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">qsklearn</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Qsklearn</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>sklearn.utils package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/sklearn.utils.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="sklearn-utils-package">
<h1>sklearn.utils package<a class="headerlink" href="#sklearn-utils-package" title="Permalink to this headline">¶</a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="sklearn.utils.tests.html">sklearn.utils.tests package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-conftest-module">sklearn.utils.tests.conftest module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-arpack-module">sklearn.utils.tests.test_arpack module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-arrayfuncs-module">sklearn.utils.tests.test_arrayfuncs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-class-weight-module">sklearn.utils.tests.test_class_weight module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-cython-blas-module">sklearn.utils.tests.test_cython_blas module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests.test_deprecation">sklearn.utils.tests.test_deprecation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-encode-module">sklearn.utils.tests.test_encode module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests.test_estimator_checks">sklearn.utils.tests.test_estimator_checks module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-estimator-html-repr-module">sklearn.utils.tests.test_estimator_html_repr module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-extmath-module">sklearn.utils.tests.test_extmath module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests.test_fast_dict">sklearn.utils.tests.test_fast_dict module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-fixes-module">sklearn.utils.tests.test_fixes module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests.test_metaestimators">sklearn.utils.tests.test_metaestimators module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-mocking-module">sklearn.utils.tests.test_mocking module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-multiclass-module">sklearn.utils.tests.test_multiclass module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests.test_murmurhash">sklearn.utils.tests.test_murmurhash module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests.test_optimize">sklearn.utils.tests.test_optimize module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-parallel-module">sklearn.utils.tests.test_parallel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests.test_pprint">sklearn.utils.tests.test_pprint module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-random-module">sklearn.utils.tests.test_random module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-seq-dataset-module">sklearn.utils.tests.test_seq_dataset module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests.test_shortest_path">sklearn.utils.tests.test_shortest_path module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests.test_show_versions">sklearn.utils.tests.test_show_versions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-sparsefuncs-module">sklearn.utils.tests.test_sparsefuncs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-stats-module">sklearn.utils.tests.test_stats module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-tags-module">sklearn.utils.tests.test_tags module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-testing-module">sklearn.utils.tests.test_testing module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-utils-module">sklearn.utils.tests.test_utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#sklearn-utils-tests-test-validation-module">sklearn.utils.tests.test_validation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.utils.tests.html#module-sklearn.utils.tests">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-sklearn.utils.arrayfuncs">
<span id="sklearn-utils-arrayfuncs-module"></span><h2>sklearn.utils.arrayfuncs module<a class="headerlink" href="#module-sklearn.utils.arrayfuncs" title="Permalink to this headline">¶</a></h2>
<p>Small collection of auxiliary functions that operate on arrays</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.utils.arrayfuncs.cholesky_delete">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.arrayfuncs.</span></span><span class="sig-name descname"><span class="pre">cholesky_delete</span></span><a class="headerlink" href="#sklearn.utils.arrayfuncs.cholesky_delete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.arrayfuncs.min_pos">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.arrayfuncs.</span></span><span class="sig-name descname"><span class="pre">min_pos</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.arrayfuncs.min_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum value of an array over positive values</p>
<p>Returns the maximum representable value of the input dtype if none of the
values are positive.</p>
</dd></dl>

</section>
<section id="id1">
<h2>sklearn.utils.arrayfuncs module<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-0"></span><p>Small collection of auxiliary functions that operate on arrays</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.arrayfuncs.</span></span><span class="sig-name descname"><span class="pre">cholesky_delete</span></span><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id2">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.arrayfuncs.</span></span><span class="sig-name descname"><span class="pre">min_pos</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id2" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum value of an array over positive values</p>
<p>Returns the maximum representable value of the input dtype if none of the
values are positive.</p>
</dd></dl>

</section>
<section id="module-sklearn.utils.class_weight">
<span id="sklearn-utils-class-weight-module"></span><h2>sklearn.utils.class_weight module<a class="headerlink" href="#module-sklearn.utils.class_weight" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.class_weight.compute_class_weight">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.class_weight.</span></span><span class="sig-name descname"><span class="pre">compute_class_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_weight</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.class_weight.compute_class_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate class weights for unbalanced datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_weight</strong> (<em>dict</em><em>, </em><em>'balanced'</em><em> or </em><em>None</em>) – If ‘balanced’, class weights will be given by
<code class="docutils literal notranslate"><span class="pre">n_samples</span> <span class="pre">/</span> <span class="pre">(n_classes</span> <span class="pre">*</span> <span class="pre">np.bincount(y))</span></code>.
If a dictionary is given, keys are classes and values
are corresponding class weights.
If None is given, the class weights will be uniform.</p></li>
<li><p><strong>classes</strong> (<em>ndarray</em>) – Array of the classes occurring in the data, as given by
<code class="docutils literal notranslate"><span class="pre">np.unique(y_org)</span></code> with <code class="docutils literal notranslate"><span class="pre">y_org</span></code> the original class labels.</p></li>
<li><p><strong>y</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em>) – Array of original class labels per sample.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>class_weight_vect</strong> – Array with class_weight_vect[i] the weight for i-th class.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_classes,)</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>The “balanced” heuristic is inspired by
Logistic Regression in Rare Events Data, King, Zen, 2001.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.class_weight.compute_sample_weight">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.class_weight.</span></span><span class="sig-name descname"><span class="pre">compute_sample_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.class_weight.compute_sample_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate sample weights by class for unbalanced datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_weight</strong> (<em>dict</em><em>, </em><em>list of dicts</em><em>, </em><em>&quot;balanced&quot;</em><em>, or </em><em>None</em>) – <p>Weights associated with classes in the form <code class="docutils literal notranslate"><span class="pre">{class_label:</span> <span class="pre">weight}</span></code>.
If not given, all classes are supposed to have weight one. For
multi-output problems, a list of dicts can be provided in the same
order as the columns of y.</p>
<p>Note that for multioutput (including multilabel) weights should be
defined for each class of every column in its own dict. For example,
for four-class multilabel classification weights should be
[{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of
[{1:1}, {2:5}, {3:1}, {4:1}].</p>
<p>The “balanced” mode uses the values of y to automatically adjust
weights inversely proportional to class frequencies in the input data:
<code class="docutils literal notranslate"><span class="pre">n_samples</span> <span class="pre">/</span> <span class="pre">(n_classes</span> <span class="pre">*</span> <span class="pre">np.bincount(y))</span></code>.</p>
<p>For multi-output, the weights of each column of y will be multiplied.</p>
</p></li>
<li><p><strong>y</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or </em><em>(</em><em>n_samples</em><em>, </em><em>n_outputs</em><em>)</em>) – Array of original class labels per sample.</p></li>
<li><p><strong>indices</strong> (<em>array-like of shape</em><em> (</em><em>n_subsample</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – Array of indices to be used in a subsample. Can be of length less than
n_samples in the case of a subsample, or equal to n_samples in the
case of a bootstrap subsample with repeated indices. If None, the
sample weight will be calculated over the full sample. Only “balanced”
is supported for class_weight if this is provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sample_weight_vect</strong> – Array with sample weights as applied to the original y.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-sklearn.utils.deprecation">
<span id="sklearn-utils-deprecation-module"></span><h2>sklearn.utils.deprecation module<a class="headerlink" href="#module-sklearn.utils.deprecation" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="sklearn.utils.deprecation.deprecated">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sklearn.utils.deprecation.</span></span><span class="sig-name descname"><span class="pre">deprecated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.deprecation.deprecated" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Decorator to mark a function or class as deprecated.</p>
<p>Issue a warning when the function is called/the class is instantiated and
adds a warning to the docstring.</p>
<p>The optional extra argument will be appended to the deprecation message
and the docstring. Note: to use this with the default value for extra, put
in an empty of parentheses:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deprecated</span><span class="p">()</span>
<span class="go">&lt;sklearn.utils.deprecation.deprecated object at ...&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@deprecated</span><span class="p">()</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">some_function</span><span class="p">():</span> <span class="k">pass</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>extra</strong> (<em>str</em><em>, </em><em>default=''</em>) – To be added to the deprecation messages.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-sklearn.utils.estimator_checks">
<span id="sklearn-utils-estimator-checks-module"></span><h2>sklearn.utils.estimator_checks module<a class="headerlink" href="#module-sklearn.utils.estimator_checks" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_class_weight_balanced_classifiers">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_class_weight_balanced_classifiers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classifier_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_train</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_train</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_class_weight_balanced_classifiers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_class_weight_balanced_linear_classifier">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_class_weight_balanced_linear_classifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Classifier</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_class_weight_balanced_linear_classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Test class weights with non-contiguous class labels.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_class_weight_classifiers">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_class_weight_classifiers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classifier_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_class_weight_classifiers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_classifier_data_not_an_array">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_classifier_data_not_an_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_classifier_data_not_an_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_classifier_multioutput">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_classifier_multioutput</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_classifier_multioutput" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_classifiers_classes">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_classifiers_classes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classifier_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_classifiers_classes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_classifiers_multilabel_representation_invariance">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_classifiers_multilabel_representation_invariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classifier_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_classifiers_multilabel_representation_invariance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_classifiers_one_label">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_classifiers_one_label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classifier_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_classifiers_one_label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_classifiers_predictions">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_classifiers_predictions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classifier_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_classifiers_predictions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_classifiers_regression_target">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_classifiers_regression_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_classifiers_regression_target" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_classifiers_train">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_classifiers_train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classifier_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">readonly_memmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float64'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_classifiers_train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_clusterer_compute_labels_predict">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_clusterer_compute_labels_predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusterer_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_clusterer_compute_labels_predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that predict is invariant of compute_labels.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_clustering">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_clustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusterer_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">readonly_memmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_clustering" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_complex_data">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_complex_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_complex_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_decision_proba_consistency">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_decision_proba_consistency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_decision_proba_consistency" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_dict_unchanged">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_dict_unchanged</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_dict_unchanged" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_dont_overwrite_parameters">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_dont_overwrite_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_dont_overwrite_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_dtype_object">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_dtype_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_dtype_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimator">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Estimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generate_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if estimator adheres to scikit-learn conventions.</p>
<p>This estimator will run an extensive test-suite for input validation,
shapes, etc, making sure that the estimator complies with <cite>scikit-learn</cite>
conventions as detailed in <span class="xref std std-ref">rolling_your_own_estimator</span>.
Additional tests for classifiers, regressors, clustering or transformers
will be run if the Estimator class inherits from the corresponding mixin
from sklearn.base.</p>
<p>Setting <cite>generate_only=True</cite> returns a generator that yields (estimator,
check) tuples where the check can be called independently from each
other, i.e. <cite>check(estimator)</cite>. This allows all checks to be run
independently and report the checks that are failing.</p>
<p>scikit-learn provides a pytest specific decorator,
<code class="xref py py-func docutils literal notranslate"><span class="pre">parametrize_with_checks()</span></code>, making it easier to test
multiple estimators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Estimator</strong> (<em>estimator object</em>) – <p>Estimator instance to check.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.24: </span>Passing a class was deprecated in version 0.23, and support for
classes was removed in 0.24.</p>
</div>
</p></li>
<li><p><strong>generate_only</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <p>When <cite>False</cite>, checks are evaluated when <cite>check_estimator</cite> is called.
When <cite>True</cite>, <cite>check_estimator</cite> returns a generator that yields
(estimator, check) tuples. The check is run by calling
<cite>check(estimator)</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.22.</span></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>checks_generator</strong> – Generator that yields (estimator, check) tuples. Returned when
<cite>generate_only=True</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>generator</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimator_get_tags_default_keys">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimator_get_tags_default_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimator_get_tags_default_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimator_sparse_data">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimator_sparse_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimator_sparse_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimators_data_not_an_array">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimators_data_not_an_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimators_data_not_an_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimators_dtypes">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimators_dtypes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimators_dtypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimators_empty_data_messages">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimators_empty_data_messages</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimators_empty_data_messages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimators_fit_returns_self">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimators_fit_returns_self</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">readonly_memmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimators_fit_returns_self" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is returned when calling fit.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimators_nan_inf">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimators_nan_inf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimators_nan_inf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimators_overwrite_params">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimators_overwrite_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimators_overwrite_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimators_partial_fit_n_features">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimators_partial_fit_n_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimators_partial_fit_n_features" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimators_pickle">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimators_pickle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimators_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that we can pickle all estimators.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_estimators_unfitted">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_estimators_unfitted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_estimators_unfitted" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that predict raises an exception in an unfitted estimator.</p>
<p>Unfitted estimators should raise a NotFittedError.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_fit1d">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_fit1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_fit1d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_fit2d_1feature">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_fit2d_1feature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_fit2d_1feature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_fit2d_1sample">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_fit2d_1sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_fit2d_1sample" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_fit2d_predict1d">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_fit2d_predict1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_fit2d_predict1d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_fit_idempotent">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_fit_idempotent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_fit_idempotent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_fit_non_negative">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_fit_non_negative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_fit_non_negative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_fit_score_takes_y">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_fit_score_takes_y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_fit_score_takes_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_get_params_invariance">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_get_params_invariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_get_params_invariance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_methods_sample_order_invariance">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_methods_sample_order_invariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_methods_sample_order_invariance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_methods_subset_invariance">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_methods_subset_invariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_methods_subset_invariance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_n_features_in">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_n_features_in</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_n_features_in" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_n_features_in_after_fitting">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_n_features_in_after_fitting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_n_features_in_after_fitting" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_no_attributes_set_in_init">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_no_attributes_set_in_init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_no_attributes_set_in_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Check setting during init.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_non_transformer_estimators_n_iter">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_non_transformer_estimators_n_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_non_transformer_estimators_n_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_nonsquare_error">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_nonsquare_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_nonsquare_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Test that error is thrown when non-square data provided.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_outlier_corruption">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_outlier_corruption</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_outliers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expected_outliers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decision</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_outlier_corruption" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_outliers_fit_predict">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_outliers_fit_predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_outliers_fit_predict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_outliers_train">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_outliers_train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">readonly_memmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_outliers_train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_parameters_default_constructible">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_parameters_default_constructible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Estimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_parameters_default_constructible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_pipeline_consistency">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_pipeline_consistency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_pipeline_consistency" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_regressor_data_not_an_array">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_regressor_data_not_an_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_regressor_data_not_an_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_regressor_multioutput">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_regressor_multioutput</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_regressor_multioutput" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_regressors_int">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_regressors_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regressor_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_regressors_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_regressors_no_decision_function">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_regressors_no_decision_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regressor_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_regressors_no_decision_function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_regressors_train">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_regressors_train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">regressor_orig</span></em>, <em class="sig-param"><span class="pre">readonly_memmap=False</span></em>, <em class="sig-param"><span class="pre">X_dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_regressors_train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_requires_y_none">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_requires_y_none</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_requires_y_none" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_sample_weights_invariance">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_sample_weights_invariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ones'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_sample_weights_invariance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_sample_weights_list">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_sample_weights_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_sample_weights_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_sample_weights_not_an_array">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_sample_weights_not_an_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_sample_weights_not_an_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_sample_weights_pandas_series">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_sample_weights_pandas_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_sample_weights_pandas_series" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_sample_weights_shape">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_sample_weights_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_sample_weights_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_set_params">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_set_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_sparsify_coefficients">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_sparsify_coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_sparsify_coefficients" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_supervised_y_2d">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_supervised_y_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_supervised_y_2d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_supervised_y_no_nan">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_supervised_y_no_nan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_supervised_y_no_nan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_transformer_data_not_an_array">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_transformer_data_not_an_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_transformer_data_not_an_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_transformer_general">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_transformer_general</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">readonly_memmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_transformer_general" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_transformer_n_iter">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_transformer_n_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_transformer_n_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_transformer_preserve_dtypes">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_transformer_preserve_dtypes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformer_orig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_transformer_preserve_dtypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.check_transformers_unfitted">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">check_transformers_unfitted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transformer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.check_transformers_unfitted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_checks.parametrize_with_checks">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.estimator_checks.</span></span><span class="sig-name descname"><span class="pre">parametrize_with_checks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimators</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_checks.parametrize_with_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>Pytest specific decorator for parametrizing estimator checks.</p>
<p>The <cite>id</cite> of each check is set to be a pprint version of the estimator
and the name of the check with its keyword arguments.
This allows to use <cite>pytest -k</cite> to specify which tests to run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pytest</span> <span class="n">test_check_estimators</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">k</span> <span class="n">check_estimators_fit_returns_self</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>estimators</strong> (<em>list of estimators instances</em>) – <p>Estimators to generated checks for.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.24: </span>Passing a class was deprecated in version 0.23, and support for
classes was removed in 0.24. Pass an instance instead.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>decorator</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>pytest.mark.parametrize</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils.estimator_checks</span> <span class="kn">import</span> <span class="n">parametrize_with_checks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeRegressor</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@parametrize_with_checks</span><span class="p">([</span><span class="n">LogisticRegression</span><span class="p">(),</span>
<span class="gp">... </span>                          <span class="n">DecisionTreeRegressor</span><span class="p">()])</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test_sklearn_compatible_estimator</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">check</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">check</span><span class="p">(</span><span class="n">estimator</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-sklearn.utils.extmath">
<span id="sklearn-utils-extmath-module"></span><h2>sklearn.utils.extmath module<a class="headerlink" href="#module-sklearn.utils.extmath" title="Permalink to this headline">¶</a></h2>
<p>Extended math utilities.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.cartesian">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">cartesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arrays</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a cartesian product of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arrays</strong> (<em>list of array-like</em>) – 1-D arrays to form the cartesian product of.</p></li>
<li><p><strong>out</strong> (<em>ndarray</em><em>, </em><em>default=None</em>) – Array to place the cartesian product in.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – 2-D array of shape (M, len(arrays)) containing cartesian products
formed of input arrays.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cartesian</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">array([[1, 4, 6],</span>
<span class="go">       [1, 4, 7],</span>
<span class="go">       [1, 5, 6],</span>
<span class="go">       [1, 5, 7],</span>
<span class="go">       [2, 4, 6],</span>
<span class="go">       [2, 4, 7],</span>
<span class="go">       [2, 5, 6],</span>
<span class="go">       [2, 5, 7],</span>
<span class="go">       [3, 4, 6],</span>
<span class="go">       [3, 4, 7],</span>
<span class="go">       [3, 5, 6],</span>
<span class="go">       [3, 5, 7]])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>This function may not be used on more than 32 arrays
because the underlying numpy functions do not support it.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.density">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.density" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density of a sparse vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>w</strong> (<em>array-like</em>) – The sparse vector.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The density of w, between 0 and 1.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.fast_logdet">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">fast_logdet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.fast_logdet" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute log(det(A)) for A symmetric.</p>
<p>Equivalent to : np.log(nl.det(A)) but more robust.
It returns -Inf if det(A) is non positive or is not defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> (<em>array-like</em>) – The matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.log_logistic">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">log_logistic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.log_logistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log of the logistic function, <code class="docutils literal notranslate"><span class="pre">log(1</span> <span class="pre">/</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">e</span> <span class="pre">**</span> <span class="pre">-x))</span></code>.</p>
<p>This implementation is numerically stable because it splits positive and
negative values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x_i</span><span class="p">))</span>     <span class="k">if</span> <span class="n">x_i</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">x_i</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x_i</span><span class="p">))</span> <span class="k">if</span> <span class="n">x_i</span> <span class="o">&lt;=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>For the ordinary logistic function, use <code class="docutils literal notranslate"><span class="pre">scipy.special.expit</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>M</em><em>, </em><em>N</em><em>) or </em><em>(</em><em>M</em><em>,</em><em>)</em>) – Argument to the logistic function.</p></li>
<li><p><strong>out</strong> (<em>array-like of shape</em><em> (</em><em>M</em><em>, </em><em>N</em><em>) or </em><em>(</em><em>M</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – Preallocated output array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Log of the logistic function evaluated at every point in x.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (M, N) or (M,)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See the blog post describing this implementation:
<a class="reference external" href="http://fa.bianp.net/blog/2013/numerical-optimizers-for-logistic-regression/">http://fa.bianp.net/blog/2013/numerical-optimizers-for-logistic-regression/</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.make_nonnegative">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">make_nonnegative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.make_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure <cite>X.min()</cite> &gt;= <cite>min_value</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em>) – The matrix to make non-negative.</p></li>
<li><p><strong>min_value</strong> (<em>float</em><em>, </em><em>default=0</em>) – The threshold value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The thresholded array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – When X is sparse.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.randomized_range_finder">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">randomized_range_finder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_iteration_normalizer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.randomized_range_finder" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an orthonormal matrix whose range approximates the range of A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>2D array</em>) – The input data matrix.</p></li>
<li><p><strong>size</strong> (<em>int</em>) – Size of the return array.</p></li>
<li><p><strong>n_iter</strong> (<em>int</em>) – Number of power iterations used to stabilize the result.</p></li>
<li><p><strong>power_iteration_normalizer</strong> (<em>{'auto'</em><em>, </em><em>'QR'</em><em>, </em><em>'LU'</em><em>, </em><em>'none'}</em><em>, </em><em>default='auto'</em>) – <p>Whether the power iterations are normalized with step-by-step
QR factorization (the slowest but most accurate), ‘none’
(the fastest but numerically unstable when <cite>n_iter</cite> is large, e.g.
typically 5 or larger), or ‘LU’ factorization (numerically stable
but can lose slightly in accuracy). The ‘auto’ mode applies no
normalization if <cite>n_iter</cite> &lt;= 2 and switches to LU otherwise.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.</span></p>
</div>
</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) – The seed of the pseudo random number generator to use when shuffling
the data, i.e. getting the random vectors to initialize the algorithm.
Pass an int for reproducible results across multiple function calls.
See <span class="xref std std-term">Glossary</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Q</strong> – A (size x size) projection matrix, the range of which
approximates well the range of the input matrix A.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Follows Algorithm 4.3 of
Finding structure with randomness: Stochastic algorithms for constructing
approximate matrix decompositions
Halko, et al., 2009 (arXiv:909) https://arxiv.org/pdf/0909.4061.pdf</p>
<p>An implementation of a randomized algorithm for principal component
analysis
A. Szlam et al. 2014</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.randomized_svd">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">randomized_svd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_components</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_oversamples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power_iteration_normalizer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transpose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flip_sign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'warn'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.randomized_svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a truncated randomized SVD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>{ndarray</em><em>, </em><em>sparse matrix}</em>) – Matrix to decompose.</p></li>
<li><p><strong>n_components</strong> (<em>int</em>) – Number of singular values and vectors to extract.</p></li>
<li><p><strong>n_oversamples</strong> (<em>int</em><em>, </em><em>default=10</em>) – Additional number of random vectors to sample the range of M so as
to ensure proper conditioning. The total number of random vectors
used to find the range of M is n_components + n_oversamples. Smaller
number can improve speed but can negatively impact the quality of
approximation of singular vectors and singular values.</p></li>
<li><p><strong>n_iter</strong> (<em>int</em><em> or </em><em>'auto'</em><em>, </em><em>default='auto'</em>) – <p>Number of power iterations. It can be used to deal with very noisy
problems. When ‘auto’, it is set to 4, unless <cite>n_components</cite> is small
(&lt; .1 * min(X.shape)) <cite>n_iter</cite> in which case is set to 7.
This improves precision with few components.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.</span></p>
</div>
</p></li>
<li><p><strong>power_iteration_normalizer</strong> (<em>{'auto'</em><em>, </em><em>'QR'</em><em>, </em><em>'LU'</em><em>, </em><em>'none'}</em><em>, </em><em>default='auto'</em>) – <p>Whether the power iterations are normalized with step-by-step
QR factorization (the slowest but most accurate), ‘none’
(the fastest but numerically unstable when <cite>n_iter</cite> is large, e.g.
typically 5 or larger), or ‘LU’ factorization (numerically stable
but can lose slightly in accuracy). The ‘auto’ mode applies no
normalization if <cite>n_iter</cite> &lt;= 2 and switches to LU otherwise.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.</span></p>
</div>
</p></li>
<li><p><strong>transpose</strong> (<em>bool</em><em> or </em><em>'auto'</em><em>, </em><em>default='auto'</em>) – <p>Whether the algorithm should be applied to M.T instead of M. The
result should approximately be the same. The ‘auto’ mode will
trigger the transposition if M.shape[1] &gt; M.shape[0] since this
implementation of randomized SVD tend to be a little faster in that
case.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.</span></p>
</div>
</p></li>
<li><p><strong>flip_sign</strong> (<em>bool</em><em>, </em><em>default=True</em>) – The output of a singular value decomposition is only unique up to a
permutation of the signs of the singular vectors. If <cite>flip_sign</cite> is
set to <cite>True</cite>, the sign ambiguity is resolved by making the largest
loadings for each component in the left singular vectors positive.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>default='warn'</em>) – <p>The seed of the pseudo random number generator to use when
shuffling the data, i.e. getting the random vectors to initialize
the algorithm. Pass an int for reproducible results across multiple
function calls. See <span class="xref std std-term">Glossary</span>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.2: </span>The previous behavior (<cite>random_state=0</cite>) is deprecated, and
from v1.2 the default value will be <cite>random_state=None</cite>. Set
the value of <cite>random_state</cite> explicitly to suppress the deprecation
warning.</p>
</div>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This algorithm finds a (usually very good) approximate truncated
singular value decomposition using randomization to speed up the
computations. It is particularly fast on large matrices on which
you wish to extract only a small number of components. In order to
obtain further speed up, <cite>n_iter</cite> can be set &lt;=2 (at the cost of
loss of precision).</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Finding structure with randomness: Stochastic algorithms for constructing
approximate matrix decompositions
Halko, et al., 2009 <a class="reference external" href="https://arxiv.org/abs/0909.4061">https://arxiv.org/abs/0909.4061</a></p></li>
<li><p>A randomized algorithm for the decomposition of matrices
Per-Gunnar Martinsson, Vladimir Rokhlin and Mark Tygert</p></li>
<li><p>An implementation of a randomized algorithm for principal component
analysis
A. Szlam et al. 2014</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.row_norms">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">row_norms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squared</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.row_norms" title="Permalink to this definition">¶</a></dt>
<dd><p>Row-wise (squared) Euclidean norm of X.</p>
<p>Equivalent to np.sqrt((X * X).sum(axis=1)), but also supports sparse
matrices and does not create an X.shape-sized temporary.</p>
<p>Performs no input validation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em>) – The input array.</p></li>
<li><p><strong>squared</strong> (<em>bool</em><em>, </em><em>default=False</em>) – If True, return squared norms.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The row-wise (squared) Euclidean norm of X.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.safe_sparse_dot">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">safe_sparse_dot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dense_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.safe_sparse_dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product that handle the sparse matrix case correctly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>{ndarray</em><em>, </em><em>sparse matrix}</em>) – </p></li>
<li><p><strong>b</strong> (<em>{ndarray</em><em>, </em><em>sparse matrix}</em>) – </p></li>
<li><p><strong>dense_output</strong> (<em>bool</em><em>, </em><em>default=False</em>) – When False, <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> both being sparse will yield sparse output.
When True, output will always be a dense array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dot_product</strong> – Sparse if <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are sparse and <code class="docutils literal notranslate"><span class="pre">dense_output=False</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{ndarray, sparse matrix}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.softmax">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">softmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the softmax function.</p>
<p>The softmax function is calculated by
np.exp(X) / np.sum(np.exp(X), axis=1)</p>
<p>This will cause overflow when large values are exponentiated.
Hence the largest value in each row is subtracted from each data
point to prevent this.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like of float of shape</em><em> (</em><em>M</em><em>, </em><em>N</em><em>)</em>) – Argument to the logistic function.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Copy X or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Softmax function evaluated at every point in x.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (M, N)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.squared_norm">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">squared_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.squared_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Squared Euclidean or Frobenius norm of x.</p>
<p>Faster than norm(x) ** 2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>array-like</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Euclidean norm when x is a vector, the Frobenius norm when x
is a matrix (2-d array).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.stable_cumsum">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">stable_cumsum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.stable_cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Use high precision for cumsum and check that final value matches sum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>array-like</em>) – To be cumulatively summed as flat.</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>default=None</em>) – Axis along which the cumulative sum is computed.
The default (None) is to compute the cumsum over the flattened array.</p></li>
<li><p><strong>rtol</strong> (<em>float</em><em>, </em><em>default=1e-05</em>) – Relative tolerance, see <code class="docutils literal notranslate"><span class="pre">np.allclose</span></code>.</p></li>
<li><p><strong>atol</strong> (<em>float</em><em>, </em><em>default=1e-08</em>) – Absolute tolerance, see <code class="docutils literal notranslate"><span class="pre">np.allclose</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.svd_flip">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">svd_flip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_based_decision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.svd_flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Sign correction to ensure deterministic output from SVD.</p>
<p>Adjusts the columns of u and the rows of v such that the loadings in the
columns in u that are largest in absolute value are always positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>ndarray</em>) – u and v are the output of <cite>linalg.svd</cite> or
<a class="reference internal" href="#sklearn.utils.extmath.randomized_svd" title="sklearn.utils.extmath.randomized_svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">randomized_svd()</span></code></a>, with matching inner
dimensions so one can compute <cite>np.dot(u * s, v)</cite>.</p></li>
<li><p><strong>v</strong> (<em>ndarray</em>) – u and v are the output of <cite>linalg.svd</cite> or
<a class="reference internal" href="#sklearn.utils.extmath.randomized_svd" title="sklearn.utils.extmath.randomized_svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">randomized_svd()</span></code></a>, with matching inner
dimensions so one can compute <cite>np.dot(u * s, v)</cite>.
The input v should really be called vt to be consistent with scipy’s
ouput.</p></li>
<li><p><strong>u_based_decision</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True, use the columns of u as the basis for sign flipping.
Otherwise, use the rows of v. The choice of which variable to base the
decision on is generally algorithm dependent.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>u_adjusted, v_adjusted</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>arrays with the same dimensions as the input.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.extmath.weighted_mode">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.extmath.</span></span><span class="sig-name descname"><span class="pre">weighted_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.extmath.weighted_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of the weighted modal (most common) value in a.</p>
<p>If there is more than one such value, only the first is returned.
The bin-count for the modal bins is also returned.</p>
<p>This is an extension of the algorithm in scipy.stats.mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>array-like</em>) – n-dimensional array of which to find mode(s).</p></li>
<li><p><strong>w</strong> (<em>array-like</em>) – n-dimensional array of weights for each value.</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>default=0</em>) – Axis along which to operate. Default is 0, i.e. the first axis.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vals</strong> (<em>ndarray</em>) – Array of modal values.</p></li>
<li><p><strong>score</strong> (<em>ndarray</em>) – Array of weighted counts for each mode.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils.extmath</span> <span class="kn">import</span> <span class="n">weighted_mode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weighted_mode</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
<span class="go">(array([4.]), array([3.]))</span>
</pre></div>
</div>
<p>The value 4 appears three times: with uniform weights, the result is
simply the mode of the distribution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># deweight the 4&#39;s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weighted_mode</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
<span class="go">(array([2.]), array([3.5]))</span>
</pre></div>
</div>
<p>The value 2 has the highest score: it appears twice with weights of
1.5 and 2: the sum of these is 3.5.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.mode</span></code></p>
</div>
</dd></dl>

</section>
<section id="module-sklearn.utils.fixes">
<span id="sklearn-utils-fixes-module"></span><h2>sklearn.utils.fixes module<a class="headerlink" href="#module-sklearn.utils.fixes" title="Permalink to this headline">¶</a></h2>
<p>Compatibility fixes for older version of python, numpy and scipy</p>
<p>If you add content to this file, please give the version of the package
at which the fixe is no longer needed.</p>
<dl class="py class">
<dt class="sig sig-object py" id="sklearn.utils.fixes.MaskedArray">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sklearn.utils.fixes.</span></span><span class="sig-name descname"><span class="pre">MaskedArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hard_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shrink</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.fixes.MaskedArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ma.core.MaskedArray</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.fixes.delayed">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.fixes.</span></span><span class="sig-name descname"><span class="pre">delayed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.fixes.delayed" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator used to capture the arguments of a function.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.fixes.linspace">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.fixes.</span></span><span class="sig-name descname"><span class="pre">linspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.fixes.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a simplified linspace function as of numpy verion &gt;= 1.16.</p>
<p>As of numpy 1.16, the arguments start and stop can be array-like and
there is an optional argument <cite>axis</cite>.
For simplicity, we only allow 1d array-like to be passed to start and stop.
See: <a class="reference external" href="https://github.com/numpy/numpy/pull/12388">https://github.com/numpy/numpy/pull/12388</a> and numpy 1.16 release
notes about start and stop arrays for linspace logspace and geomspace.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – The output array with <cite>n_start=start.shape[0]</cite> columns.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray of shape (num, n_start) or (num,)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-sklearn.utils.graph">
<span id="sklearn-utils-graph-module"></span><h2>sklearn.utils.graph module<a class="headerlink" href="#module-sklearn.utils.graph" title="Permalink to this headline">¶</a></h2>
<p>Graph utilities and algorithms</p>
<p>Graphs are represented with their adjacency matrices, preferably using
sparse matrices.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.graph.single_source_shortest_path_length">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.graph.</span></span><span class="sig-name descname"><span class="pre">single_source_shortest_path_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.graph.single_source_shortest_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the shortest path length from source to all reachable nodes.</p>
<p>Returns a dictionary of shortest path lengths keyed by target.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>{sparse matrix</em><em>, </em><em>ndarray} of shape</em><em> (</em><em>n</em><em>, </em><em>n</em><em>)</em>) – Adjacency matrix of the graph. Sparse matrix of format LIL is
preferred.</p></li>
<li><p><strong>source</strong> (<em>int</em>) – Starting node for path.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em><em>, </em><em>default=None</em>) – Depth to stop the search - only paths of length &lt;= cutoff are returned.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils.graph</span> <span class="kn">import</span> <span class="n">single_source_shortest_path_length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">single_source_shortest_path_length</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
<span class="go">[(0, 0), (1, 1), (2, 2), (3, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">single_source_shortest_path_length</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
<span class="go">[(0, 1), (1, 1), (2, 0), (3, 1), (4, 1), (5, 1)]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-sklearn.utils.graph_shortest_path">
<span id="sklearn-utils-graph-shortest-path-module"></span><h2>sklearn.utils.graph_shortest_path module<a class="headerlink" href="#module-sklearn.utils.graph_shortest_path" title="Permalink to this headline">¶</a></h2>
<p>Routines for performing shortest-path graph searches</p>
<p>The main interface is in the function <cite>graph_shortest_path</cite>.  This
calls cython routines that compute the shortest path using either
the Floyd-Warshall algorithm, or Dykstra’s algorithm with Fibonacci Heaps.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.graph_shortest_path.graph_shortest_path">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.graph_shortest_path.</span></span><span class="sig-name descname"><span class="pre">graph_shortest_path</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.graph_shortest_path.graph_shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a shortest-path graph search on a positive directed or
undirected graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dist_matrix</strong> (<em>arraylike</em><em> or </em><em>sparse matrix</em><em>, </em><em>shape =</em><em> (</em><em>N</em><em>,</em><em>N</em><em>)</em>) – Array of positive distances.
If vertex i is connected to vertex j, then dist_matrix[i,j] gives
the distance between the vertices.
If vertex i is not connected to vertex j, then dist_matrix[i,j] = 0</p></li>
<li><p><strong>directed</strong> (<em>boolean</em>) – if True, then find the shortest path on a directed graph: only
progress from a point to its neighbors, not the other way around.
if False, then find the shortest path on an undirected graph: the
algorithm can progress from a point to its neighbors and vice versa.</p></li>
<li><p><strong>method</strong> (<em>string</em><em> [</em><em>'auto'</em><em>|</em><em>'FW'</em><em>|</em><em>'D'</em><em>]</em>) – method to use.  Options are
‘auto’ : attempt to choose the best method for the current problem
‘FW’ : Floyd-Warshall algorithm.  O[N^3]
‘D’ : Dijkstra’s algorithm with Fibonacci stacks.  O[(k+log(N))N^2]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – G[i,j] gives the shortest distance from point i to point j
along the graph.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray, float, shape = [N,N]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As currently implemented, Dijkstra’s algorithm does not work for
graphs with direction-dependent distances when directed == False.
i.e., if dist_matrix[i,j] and dist_matrix[j,i] are not equal and
both are nonzero, method=’D’ will not necessarily yield the correct
result.</p>
<p>Also, these routines have not been tested for graphs with negative
distances.  Negative distances can lead to infinite cycles that must
be handled by specialized algorithms.</p>
</dd></dl>

</section>
<section id="id3">
<h2>sklearn.utils.graph_shortest_path module<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-1"></span><p>Routines for performing shortest-path graph searches</p>
<p>The main interface is in the function <cite>graph_shortest_path</cite>.  This
calls cython routines that compute the shortest path using either
the Floyd-Warshall algorithm, or Dykstra’s algorithm with Fibonacci Heaps.</p>
<dl class="py function">
<dt class="sig sig-object py" id="id4">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.graph_shortest_path.</span></span><span class="sig-name descname"><span class="pre">graph_shortest_path</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id4" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a shortest-path graph search on a positive directed or
undirected graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dist_matrix</strong> (<em>arraylike</em><em> or </em><em>sparse matrix</em><em>, </em><em>shape =</em><em> (</em><em>N</em><em>,</em><em>N</em><em>)</em>) – Array of positive distances.
If vertex i is connected to vertex j, then dist_matrix[i,j] gives
the distance between the vertices.
If vertex i is not connected to vertex j, then dist_matrix[i,j] = 0</p></li>
<li><p><strong>directed</strong> (<em>boolean</em>) – if True, then find the shortest path on a directed graph: only
progress from a point to its neighbors, not the other way around.
if False, then find the shortest path on an undirected graph: the
algorithm can progress from a point to its neighbors and vice versa.</p></li>
<li><p><strong>method</strong> (<em>string</em><em> [</em><em>'auto'</em><em>|</em><em>'FW'</em><em>|</em><em>'D'</em><em>]</em>) – method to use.  Options are
‘auto’ : attempt to choose the best method for the current problem
‘FW’ : Floyd-Warshall algorithm.  O[N^3]
‘D’ : Dijkstra’s algorithm with Fibonacci stacks.  O[(k+log(N))N^2]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>G</strong> – G[i,j] gives the shortest distance from point i to point j
along the graph.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray, float, shape = [N,N]</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As currently implemented, Dijkstra’s algorithm does not work for
graphs with direction-dependent distances when directed == False.
i.e., if dist_matrix[i,j] and dist_matrix[j,i] are not equal and
both are nonzero, method=’D’ will not necessarily yield the correct
result.</p>
<p>Also, these routines have not been tested for graphs with negative
distances.  Negative distances can lead to infinite cycles that must
be handled by specialized algorithms.</p>
</dd></dl>

</section>
<section id="module-sklearn.utils.metaestimators">
<span id="sklearn-utils-metaestimators-module"></span><h2>sklearn.utils.metaestimators module<a class="headerlink" href="#module-sklearn.utils.metaestimators" title="Permalink to this headline">¶</a></h2>
<p>Utilities for meta-estimators</p>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.metaestimators.if_delegate_has_method">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.metaestimators.</span></span><span class="sig-name descname"><span class="pre">if_delegate_has_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delegate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.metaestimators.if_delegate_has_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a decorator for methods that are delegated to a sub-estimator</p>
<p>This enables ducktyping by hasattr returning True according to the
sub-estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>delegate</strong> (<em>string</em><em>, </em><em>list of strings</em><em> or </em><em>tuple of strings</em>) – Name of the sub-estimator that can be accessed as an attribute of the
base object. If a list or a tuple of names are provided, the first
sub-estimator that is an attribute of the base object will be used.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-sklearn.utils.multiclass">
<span id="sklearn-utils-multiclass-module"></span><h2>sklearn.utils.multiclass module<a class="headerlink" href="#module-sklearn.utils.multiclass" title="Permalink to this headline">¶</a></h2>
<section id="multi-class-multi-label-utility-function">
<h3>Multi-class / multi-label utility function<a class="headerlink" href="#multi-class-multi-label-utility-function" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.multiclass.check_classification_targets">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.multiclass.</span></span><span class="sig-name descname"><span class="pre">check_classification_targets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.multiclass.check_classification_targets" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that target y is of a non-regression type.</p>
<dl class="simple">
<dt>Only the following target types (as defined in type_of_target) are allowed:</dt><dd><p>‘binary’, ‘multiclass’, ‘multiclass-multioutput’,
‘multilabel-indicator’, ‘multilabel-sequences’</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>y</strong> (<em>array-like</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.multiclass.class_distribution">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.multiclass.</span></span><span class="sig-name descname"><span class="pre">class_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.multiclass.class_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute class priors from multioutput-multiclass target data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>{array-like</em><em>, </em><em>sparse matrix} of size</em><em> (</em><em>n_samples</em><em>, </em><em>n_outputs</em><em>)</em>) – The labels for each example.</p></li>
<li><p><strong>sample_weight</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – Sample weights.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>classes</strong> (<em>list of size n_outputs of ndarray of size (n_classes,)</em>) – List of classes for each column.</p></li>
<li><p><strong>n_classes</strong> (<em>list of int of size n_outputs</em>) – Number of classes in each column.</p></li>
<li><p><strong>class_prior</strong> (<em>list of size n_outputs of ndarray of size (n_classes,)</em>) – Class distribution of each column.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.multiclass.is_multilabel">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.multiclass.</span></span><span class="sig-name descname"><span class="pre">is_multilabel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.multiclass.is_multilabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">y</span></code> is in a multilabel format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>y</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em>) – Target values.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Return <code class="docutils literal notranslate"><span class="pre">True</span></code>, if <code class="docutils literal notranslate"><span class="pre">y</span></code> is in a multilabel format, else <code class="docutils literal notranslate"><span class="pre">`False</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils.multiclass</span> <span class="kn">import</span> <span class="n">is_multilabel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_multilabel</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_multilabel</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[]])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_multilabel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_multilabel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_multilabel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.multiclass.type_of_target">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.multiclass.</span></span><span class="sig-name descname"><span class="pre">type_of_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.multiclass.type_of_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the type of data indicated by the target.</p>
<p>Note that this type is the most specific type that can be inferred.
For example:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">binary</span></code> is more specific but compatible with <code class="docutils literal notranslate"><span class="pre">multiclass</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">multiclass</span></code> of integers is more specific but compatible with
<code class="docutils literal notranslate"><span class="pre">continuous</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">multilabel-indicator</span></code> is more specific but compatible with
<code class="docutils literal notranslate"><span class="pre">multiclass-multioutput</span></code>.</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>y</strong> (<em>array-like</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>target_type</strong> – One of:</p>
<ul class="simple">
<li><p>’continuous’: <cite>y</cite> is an array-like of floats that are not all
integers, and is 1d or a column vector.</p></li>
<li><p>’continuous-multioutput’: <cite>y</cite> is a 2d array of floats that are
not all integers, and both dimensions are of size &gt; 1.</p></li>
<li><p>’binary’: <cite>y</cite> contains &lt;= 2 discrete values and is 1d or a column
vector.</p></li>
<li><p>’multiclass’: <cite>y</cite> contains more than two discrete values, is not a
sequence of sequences, and is 1d or a column vector.</p></li>
<li><p>’multiclass-multioutput’: <cite>y</cite> is a 2d array that contains more
than two discrete values, is not a sequence of sequences, and both
dimensions are of size &gt; 1.</p></li>
<li><p>’multilabel-indicator’: <cite>y</cite> is a label indicator matrix, an array
of two dimensions with at least two columns, and at most 2 unique
values.</p></li>
<li><p>’unknown’: <cite>y</cite> is array-like but none of the above, such as a 3d
array, sequence of sequences, or an array of non-sequence objects.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
<span class="go">&#39;continuous&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">&#39;binary&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="go">&#39;binary&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="go">&#39;binary&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">&#39;multiclass&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="go">&#39;multiclass&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="go">&#39;multiclass&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span>
<span class="go">&#39;multiclass-multioutput&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">&#39;multilabel-indicator&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">]]))</span>
<span class="go">&#39;continuous-multioutput&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">type_of_target</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span>
<span class="go">&#39;multilabel-indicator&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.multiclass.unique_labels">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.multiclass.</span></span><span class="sig-name descname"><span class="pre">unique_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.multiclass.unique_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract an ordered array of unique labels.</p>
<dl class="simple">
<dt>We don’t allow:</dt><dd><ul class="simple">
<li><p>mix of multilabel and multiclass (single label) targets</p></li>
<li><p>mix of label indicator matrix and anything else,
because there are no explicit labels)</p></li>
<li><p>mix of label indicator matrices of different sizes</p></li>
<li><p>mix of string and integer labels</p></li>
</ul>
</dd>
</dl>
<p>At the moment, we also don’t allow “multiclass-multioutput” input type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*ys</strong> (<em>array-likes</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – An ordered array of unique labels.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_unique_labels,)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils.multiclass</span> <span class="kn">import</span> <span class="n">unique_labels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_labels</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">array([3, 5, 7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_labels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">array([1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_labels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="go">array([ 1,  2,  5, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-sklearn.utils.murmurhash">
<span id="sklearn-utils-murmurhash-module"></span><h2>sklearn.utils.murmurhash module<a class="headerlink" href="#module-sklearn.utils.murmurhash" title="Permalink to this headline">¶</a></h2>
<p>Cython wrapper for MurmurHash3 non-cryptographic hash function.</p>
<p>MurmurHash is an extensively tested and very fast hash function that has
good distribution properties suitable for machine learning use cases
such as feature hashing and random projections.</p>
<p>The original C++ code by Austin Appleby is released the public domain
and can be found here:</p>
<blockquote>
<div><p><a class="reference external" href="https://code.google.com/p/smhasher/">https://code.google.com/p/smhasher/</a></p>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.murmurhash.murmurhash3_32">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.murmurhash.murmurhash3_32" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of key at seed.</p>
<p>The underlying implementation is MurmurHash3_x86_32 generating low
latency 32bits hash suitable for implementing lookup tables, Bloom
filters, count min sketch or feature hashing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<em>np.int32</em><em>, </em><em>bytes</em><em>, </em><em>unicode</em><em> or </em><em>ndarray of dtype=np.int32</em>) – The physical object to hash.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>default=0</em>) – Integer seed for the hashing algorithm.</p></li>
<li><p><strong>positive</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <dl class="simple">
<dt>True: the results is casted to an unsigned int</dt><dd><p>from 0 to 2 ** 32 - 1</p>
</dd>
<dt>False: the results is casted to a signed int</dt><dd><p>from -(2 ** 31) to 2 ** 31 - 1</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.murmurhash.murmurhash3_bytes_array_s32">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_bytes_array_s32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.murmurhash.murmurhash3_bytes_array_s32" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute 32bit murmurhash3 hashes of a key int array at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.murmurhash.murmurhash3_bytes_array_u32">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_bytes_array_u32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.murmurhash.murmurhash3_bytes_array_u32" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute 32bit murmurhash3 hashes of a key int array at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.murmurhash.murmurhash3_bytes_s32">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_bytes_s32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.murmurhash.murmurhash3_bytes_s32" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of a bytes key at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.murmurhash.murmurhash3_bytes_u32">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_bytes_u32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.murmurhash.murmurhash3_bytes_u32" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of a bytes key at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.murmurhash.murmurhash3_int_s32">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_int_s32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.murmurhash.murmurhash3_int_s32" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of a int key at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.murmurhash.murmurhash3_int_u32">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_int_u32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.murmurhash.murmurhash3_int_u32" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of a int key at seed.</p>
</dd></dl>

</section>
<section id="id5">
<h2>sklearn.utils.murmurhash module<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-2"></span><p>Cython wrapper for MurmurHash3 non-cryptographic hash function.</p>
<p>MurmurHash is an extensively tested and very fast hash function that has
good distribution properties suitable for machine learning use cases
such as feature hashing and random projections.</p>
<p>The original C++ code by Austin Appleby is released the public domain
and can be found here:</p>
<blockquote>
<div><p><a class="reference external" href="https://code.google.com/p/smhasher/">https://code.google.com/p/smhasher/</a></p>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="id6">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id6" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of key at seed.</p>
<p>The underlying implementation is MurmurHash3_x86_32 generating low
latency 32bits hash suitable for implementing lookup tables, Bloom
filters, count min sketch or feature hashing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<em>np.int32</em><em>, </em><em>bytes</em><em>, </em><em>unicode</em><em> or </em><em>ndarray of dtype=np.int32</em>) – The physical object to hash.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>default=0</em>) – Integer seed for the hashing algorithm.</p></li>
<li><p><strong>positive</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <dl class="simple">
<dt>True: the results is casted to an unsigned int</dt><dd><p>from 0 to 2 ** 32 - 1</p>
</dd>
<dt>False: the results is casted to a signed int</dt><dd><p>from -(2 ** 31) to 2 ** 31 - 1</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id7">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_bytes_array_s32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id7" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute 32bit murmurhash3 hashes of a key int array at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id8">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_bytes_array_u32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id8" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute 32bit murmurhash3 hashes of a key int array at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id9">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_bytes_s32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id9" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of a bytes key at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id10">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_bytes_u32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id10" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of a bytes key at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id11">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_int_s32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id11" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of a int key at seed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id12">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.murmurhash.</span></span><span class="sig-name descname"><span class="pre">murmurhash3_int_u32</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id12" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 32bit murmurhash3 of a int key at seed.</p>
</dd></dl>

</section>
<section id="module-sklearn.utils.optimize">
<span id="sklearn-utils-optimize-module"></span><h2>sklearn.utils.optimize module<a class="headerlink" href="#module-sklearn.utils.optimize" title="Permalink to this headline">¶</a></h2>
<p>Our own implementation of the Newton algorithm</p>
<p>Unlike the scipy.optimize version, this version of the Newton conjugate
gradient solver uses only one function call to retrieve the
func value, the gradient value and a callable for the Hessian matvec
product. If the function call is very expensive (e.g. for logistic
regression with large design matrix), this approach gives very
significant speedups.</p>
</section>
<section id="module-sklearn.utils.random">
<span id="sklearn-utils-random-module"></span><h2>sklearn.utils.random module<a class="headerlink" href="#module-sklearn.utils.random" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.random.sample_without_replacement">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.random.</span></span><span class="sig-name descname"><span class="pre">sample_without_replacement</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.random.sample_without_replacement" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample integers without replacement.</p>
<p>Select n_samples integers from the set [0, n_population) without
replacement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_population</strong> (<em>int</em>) – The size of the set to sample from.</p></li>
<li><p><strong>n_samples</strong> (<em>int</em>) – The number of integer to sample.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) – If int, random_state is the seed used by the random number generator;
If RandomState instance, random_state is the random number generator;
If None, the random number generator is the RandomState instance used
by <cite>np.random</cite>.</p></li>
<li><p><strong>method</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>&quot;tracking_selection&quot;</em><em>, </em><em>&quot;reservoir_sampling&quot;</em><em>, </em><em>&quot;pool&quot;}</em><em>,             </em><em>default='auto'</em>) – <p>If method == “auto”, the ratio of n_samples / n_population is used
to determine which algorithm to use:
If ratio is between 0 and 0.01, tracking selection is used.
If ratio is between 0.01 and 0.99, numpy.random.permutation is used.
If ratio is greater than 0.99, reservoir sampling is used.
The order of the selected integers is undefined. If a random order is
desired, the selected subset should be shuffled.</p>
<p>If method ==”tracking_selection”, a set based implementation is used
which is suitable for <cite>n_samples</cite> &lt;&lt;&lt; <cite>n_population</cite>.</p>
<p>If method == “reservoir_sampling”, a reservoir sampling algorithm is
used which is suitable for high memory constraint or when
O(<cite>n_samples</cite>) ~ O(<cite>n_population</cite>).
The order of the selected integers is undefined. If a random order is
desired, the selected subset should be shuffled.</p>
<p>If method == “pool”, a pool based algorithm is particularly fast, even
faster than the tracking selection method. However, a vector containing
the entire population has to be initialized.
If n_samples ~ n_population, the reservoir sampling method is faster.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – The sampled subsets of integer. The subset of selected integer might
not be randomized, see the method argument.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-sklearn.utils.setup">
<span id="sklearn-utils-setup-module"></span><h2>sklearn.utils.setup module<a class="headerlink" href="#module-sklearn.utils.setup" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.setup.configuration">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.setup.</span></span><span class="sig-name descname"><span class="pre">configuration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent_package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.setup.configuration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-sklearn.utils.sparsefuncs">
<span id="sklearn-utils-sparsefuncs-module"></span><h2>sklearn.utils.sparsefuncs module<a class="headerlink" href="#module-sklearn.utils.sparsefuncs" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.count_nonzero">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">count_nonzero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.count_nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>A variant of X.getnnz() with extension to weighting on axis 0</p>
<p>Useful in efficiently calculating multilabel metrics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_labels</em><em>)</em>) – Input data. It should be of CSR format.</p></li>
<li><p><strong>axis</strong> (<em>{0</em><em>, </em><em>1}</em><em>, </em><em>default=None</em>) – The axis on which the data is aggregated.</p></li>
<li><p><strong>sample_weight</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – Weight for each row of X.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.csc_median_axis_0">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">csc_median_axis_0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.csc_median_axis_0" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the median across axis 0 of a CSC matrix.
It is equivalent to doing np.median(X, axis=0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data. It should be of CSC format.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>median</strong> – Median.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.incr_mean_variance_axis">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">incr_mean_variance_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_mean</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.incr_mean_variance_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute incremental mean and variance along an axis on a CSR or
CSC matrix.</p>
<p>last_mean, last_var are the statistics computed at the last step by this
function. Both must be initialized to 0-arrays of the proper size, i.e.
the number of features in X. last_n is the number of samples encountered
until now.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>CSR</em><em> or </em><em>CSC sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data.</p></li>
<li><p><strong>axis</strong> (<em>{0</em><em>, </em><em>1}</em>) – Axis along which the axis should be computed.</p></li>
<li><p><strong>last_mean</strong> (<em>ndarray of shape</em><em> (</em><em>n_features</em><em>,</em><em>) or </em><em>(</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>dtype=floating</em>) – Array of means to update with the new data X.
Should be of shape (n_features,) if axis=0 or (n_samples,) if axis=1.</p></li>
<li><p><strong>last_var</strong> (<em>ndarray of shape</em><em> (</em><em>n_features</em><em>,</em><em>) or </em><em>(</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>dtype=floating</em>) – Array of variances to update with the new data X.
Should be of shape (n_features,) if axis=0 or (n_samples,) if axis=1.</p></li>
<li><p><strong>last_n</strong> (<em>float</em><em> or </em><em>ndarray of shape</em><em> (</em><em>n_features</em><em>,</em><em>) or </em><em>(</em><em>n_samples</em><em>,</em><em>)</em><em>,             </em><em>dtype=floating</em>) – Sum of the weights seen so far, excluding the current weights
If not float, it should be of shape (n_samples,) if
axis=0 or (n_features,) if axis=1. If float it corresponds to
having same weights for all samples (or features).</p></li>
<li><p><strong>weights</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or </em><em>(</em><em>n_features</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – <p>If axis is set to 0 shape is (n_samples,) or
if axis is set to 1 shape is (n_features,).
If it is set to None, then samples are equally weighted.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>means</strong> (<em>ndarray of shape (n_features,) or (n_samples,), dtype=floating</em>) – Updated feature-wise means if axis = 0 or
sample-wise means if axis = 1.</p></li>
<li><p><strong>variances</strong> (<em>ndarray of shape (n_features,) or (n_samples,), dtype=floating</em>) – Updated feature-wise variances if axis = 0 or
sample-wise variances if axis = 1.</p></li>
<li><p><strong>n</strong> (<em>ndarray of shape (n_features,) or (n_samples,), dtype=integral</em>) – Updated number of seen samples per feature if axis=0
or number of seen features per sample if axis=1.</p>
<p>If weights is not None, n is a sum of the weights of the seen
samples or features instead of the actual number of seen
samples or features.</p>
</li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>NaNs are ignored in the algorithm.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.inplace_column_scale">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">inplace_column_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.inplace_column_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace column scaling of a CSC/CSR matrix.</p>
<p>Scale each feature of the data matrix by multiplying with specific scale
provided by the caller assuming a (n_samples, n_features) shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Matrix to normalize using the variance of the features. It should be
of CSC or CSR format.</p></li>
<li><p><strong>scale</strong> (<em>ndarray of shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em><em>, </em><em>dtype={np.float32</em><em>, </em><em>np.float64}</em>) – Array of precomputed feature-wise values to use for scaling.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.inplace_csr_column_scale">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">inplace_csr_column_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.inplace_csr_column_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace column scaling of a CSR matrix.</p>
<p>Scale each feature of the data matrix by multiplying with specific scale
provided by the caller assuming a (n_samples, n_features) shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Matrix to normalize using the variance of the features.
It should be of CSR format.</p></li>
<li><p><strong>scale</strong> (<em>ndarray of shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em><em>, </em><em>dtype={np.float32</em><em>, </em><em>np.float64}</em>) – Array of precomputed feature-wise values to use for scaling.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.inplace_csr_row_scale">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">inplace_csr_row_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.inplace_csr_row_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace row scaling of a CSR matrix.</p>
<p>Scale each sample of the data matrix by multiplying with specific scale
provided by the caller assuming a (n_samples, n_features) shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Matrix to be scaled. It should be of CSR format.</p></li>
<li><p><strong>scale</strong> (<em>ndarray of float of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em>) – Array of precomputed sample-wise values to use for scaling.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.inplace_row_scale">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">inplace_row_scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.inplace_row_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace row scaling of a CSR or CSC matrix.</p>
<p>Scale each row of the data matrix by multiplying with specific scale
provided by the caller assuming a (n_samples, n_features) shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Matrix to be scaled. It should be of CSR or CSC format.</p></li>
<li><p><strong>scale</strong> (<em>ndarray of shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em><em>, </em><em>dtype={np.float32</em><em>, </em><em>np.float64}</em>) – Array of precomputed sample-wise values to use for scaling.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.inplace_swap_column">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">inplace_swap_column</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.inplace_swap_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps two columns of a CSC/CSR matrix in-place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Matrix whose two columns are to be swapped. It should be of
CSR or CSC format.</p></li>
<li><p><strong>m</strong> (<em>int</em>) – Index of the column of X to be swapped.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Index of the column of X to be swapped.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.inplace_swap_row">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">inplace_swap_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.inplace_swap_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps two rows of a CSC/CSR matrix in-place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Matrix whose two rows are to be swapped. It should be of CSR or
CSC format.</p></li>
<li><p><strong>m</strong> (<em>int</em>) – Index of the row of X to be swapped.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Index of the row of X to be swapped.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.inplace_swap_row_csc">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">inplace_swap_row_csc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.inplace_swap_row_csc" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps two rows of a CSC matrix in-place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Matrix whose two rows are to be swapped. It should be of
CSC format.</p></li>
<li><p><strong>m</strong> (<em>int</em>) – Index of the row of X to be swapped.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Index of the row of X to be swapped.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.inplace_swap_row_csr">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">inplace_swap_row_csr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.inplace_swap_row_csr" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps two rows of a CSR matrix in-place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Matrix whose two rows are to be swapped. It should be of
CSR format.</p></li>
<li><p><strong>m</strong> (<em>int</em>) – Index of the row of X to be swapped.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Index of the row of X to be swapped.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.mean_variance_axis">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">mean_variance_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_sum_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.mean_variance_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance along an axis on a CSR or CSC matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data. It can be of CSR or CSC format.</p></li>
<li><p><strong>axis</strong> (<em>{0</em><em>, </em><em>1}</em>) – Axis along which the axis should be computed.</p></li>
<li><p><strong>weights</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or </em><em>(</em><em>n_features</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – <p>if axis is set to 0 shape is (n_samples,) or
if axis is set to 1 shape is (n_features,).
If it is set to None, then samples are equally weighted.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
<li><p><strong>return_sum_weights</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <p>If True, returns the sum of weights seen for each feature
if <cite>axis=0</cite> or each sample if <cite>axis=1</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>means</strong> (<em>ndarray of shape (n_features,), dtype=floating</em>) – Feature-wise means.</p></li>
<li><p><strong>variances</strong> (<em>ndarray of shape (n_features,), dtype=floating</em>) – Feature-wise variances.</p></li>
<li><p><strong>sum_weights</strong> (<em>ndarray of shape (n_features,), dtype=floating</em>) – Returned if <cite>return_sum_weights</cite> is <cite>True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs.min_max_axis">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs.</span></span><span class="sig-name descname"><span class="pre">min_max_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs.min_max_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute minimum and maximum along an axis on a CSR or CSC matrix and
optionally ignore NaN values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>sparse matrix of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data. It should be of CSR or CSC format.</p></li>
<li><p><strong>axis</strong> (<em>{0</em><em>, </em><em>1}</em>) – Axis along which the axis should be computed.</p></li>
<li><p><strong>ignore_nan</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <p>Ignore or passing through NaN values.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mins</strong> (<em>ndarray of shape (n_features,), dtype={np.float32, np.float64}</em>) – Feature-wise minima.</p></li>
<li><p><strong>maxs</strong> (<em>ndarray of shape (n_features,), dtype={np.float32, np.float64}</em>) – Feature-wise maxima.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-sklearn.utils.sparsefuncs_fast">
<span id="sklearn-utils-sparsefuncs-fast-module"></span><h2>sklearn.utils.sparsefuncs_fast module<a class="headerlink" href="#module-sklearn.utils.sparsefuncs_fast" title="Permalink to this headline">¶</a></h2>
<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs_fast.assign_rows_csr">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">assign_rows_csr</span></span><a class="headerlink" href="#sklearn.utils.sparsefuncs_fast.assign_rows_csr" title="Permalink to this definition">¶</a></dt>
<dd><p>Densify selected rows of a CSR matrix into a preallocated array.</p>
<p>Like out[out_rows] = X[X_rows].toarray() but without copying.
No-copy supported for both dtype=np.float32 and dtype=np.float64.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>scipy.sparse.csr_matrix</em><em>, </em><em>shape=</em><em>(</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – </p></li>
<li><p><strong>X_rows</strong> (<em>array</em><em>, </em><em>dtype=np.intp</em><em>, </em><em>shape=n_rows</em>) – </p></li>
<li><p><strong>out_rows</strong> (<em>array</em><em>, </em><em>dtype=np.intp</em><em>, </em><em>shape=n_rows</em>) – </p></li>
<li><p><strong>out</strong> (<em>array</em><em>, </em><em>shape=</em><em>(</em><em>arbitrary</em><em>, </em><em>n_features</em><em>)</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs_fast.csc_mean_variance_axis0">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">csc_mean_variance_axis0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs_fast.csc_mean_variance_axis0" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance along axis 0 on a CSC matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>CSC sparse matrix</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data.</p></li>
<li><p><strong>weights</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>dtype=floating</em><em>, </em><em>default=None</em>) – <p>If it is set to None samples will be equally weighted.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
<li><p><strong>return_sum_weights</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <p>If True, returns the sum of weights seen for each feature.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>means</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise means</p></li>
<li><p><strong>variances</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise variances</p></li>
<li><p><strong>sum_weights</strong> (<em>ndarray of shape (n_features,), dtype=floating</em>) – Returned if return_sum_weights is True.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs_fast.csr_mean_variance_axis0">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">csr_mean_variance_axis0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs_fast.csr_mean_variance_axis0" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance along axis 0 on a CSR matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>CSR sparse matrix</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data.</p></li>
<li><p><strong>weights</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>dtype=floating</em><em>, </em><em>default=None</em>) – <p>If it is set to None samples will be equally weighted.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
<li><p><strong>return_sum_weights</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <p>If True, returns the sum of weights seen for each feature.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>means</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise means</p></li>
<li><p><strong>variances</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise variances</p></li>
<li><p><strong>sum_weights</strong> (<em>ndarray of shape (n_features,), dtype=floating</em>) – Returned if return_sum_weights is True.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs_fast.csr_row_norms">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">csr_row_norms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs_fast.csr_row_norms" title="Permalink to this definition">¶</a></dt>
<dd><p>L2 norm of each row in CSR matrix X.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs_fast.incr_mean_variance_axis0">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">incr_mean_variance_axis0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs_fast.incr_mean_variance_axis0" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance along axis 0 on a CSR or CSC matrix.</p>
<p>last_mean, last_var are the statistics computed at the last step by this
function. Both must be initialized to 0.0. last_n is the
number of samples encountered until now and is initialized at 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>CSR</em><em> or </em><em>CSC sparse matrix</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data.</p></li>
<li><p><strong>last_mean</strong> (<em>float array with shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em>) – Array of feature-wise means to update with the new data X.</p></li>
<li><p><strong>last_var</strong> (<em>float array with shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em>) – Array of feature-wise var to update with the new data X.</p></li>
<li><p><strong>last_n</strong> (<em>float array with shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em>) – Sum of the weights seen so far (if weights are all set to 1
this will be the same as number of samples seen so far, before X).</p></li>
<li><p><strong>weights</strong> (<em>float array with shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or </em><em>None. If it is set</em>) – to None samples will be equally weighted.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>updated_mean</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise means</p></li>
<li><p><strong>updated_variance</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise variances</p></li>
<li><p><strong>updated_n</strong> (<em>int array with shape (n_features,)</em>) – Updated number of samples seen</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>NaNs are ignored during the computation.</p>
<p class="rubric">References</p>
<ol class="upperalpha simple" start="20">
<li><p>Chan, G. Golub, R. LeVeque. Algorithms for computing the sample</p></li>
</ol>
<blockquote>
<div><p>variance: recommendations, The American Statistician, Vol. 37, No. 3,
pp. 242-247</p>
</div></blockquote>
<p>Also, see the non-sparse implementation of this in
<cite>utils.extmath._batch_mean_variance_update</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs_fast.inplace_csr_row_normalize_l1">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">inplace_csr_row_normalize_l1</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs_fast.inplace_csr_row_normalize_l1" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace row normalize using the l1 norm</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.sparsefuncs_fast.inplace_csr_row_normalize_l2">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">inplace_csr_row_normalize_l2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.sparsefuncs_fast.inplace_csr_row_normalize_l2" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace row normalize using the l2 norm</p>
</dd></dl>

</section>
<section id="id13">
<h2>sklearn.utils.sparsefuncs_fast module<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-3"></span><dl class="py attribute">
<dt class="sig sig-object py" id="id14">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">assign_rows_csr</span></span><a class="headerlink" href="#id14" title="Permalink to this definition">¶</a></dt>
<dd><p>Densify selected rows of a CSR matrix into a preallocated array.</p>
<p>Like out[out_rows] = X[X_rows].toarray() but without copying.
No-copy supported for both dtype=np.float32 and dtype=np.float64.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>scipy.sparse.csr_matrix</em><em>, </em><em>shape=</em><em>(</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – </p></li>
<li><p><strong>X_rows</strong> (<em>array</em><em>, </em><em>dtype=np.intp</em><em>, </em><em>shape=n_rows</em>) – </p></li>
<li><p><strong>out_rows</strong> (<em>array</em><em>, </em><em>dtype=np.intp</em><em>, </em><em>shape=n_rows</em>) – </p></li>
<li><p><strong>out</strong> (<em>array</em><em>, </em><em>shape=</em><em>(</em><em>arbitrary</em><em>, </em><em>n_features</em><em>)</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id15">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">csc_mean_variance_axis0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id15" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance along axis 0 on a CSC matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>CSC sparse matrix</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data.</p></li>
<li><p><strong>weights</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>dtype=floating</em><em>, </em><em>default=None</em>) – <p>If it is set to None samples will be equally weighted.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
<li><p><strong>return_sum_weights</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <p>If True, returns the sum of weights seen for each feature.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>means</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise means</p></li>
<li><p><strong>variances</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise variances</p></li>
<li><p><strong>sum_weights</strong> (<em>ndarray of shape (n_features,), dtype=floating</em>) – Returned if return_sum_weights is True.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id16">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">csr_mean_variance_axis0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id16" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance along axis 0 on a CSR matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>CSR sparse matrix</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data.</p></li>
<li><p><strong>weights</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>dtype=floating</em><em>, </em><em>default=None</em>) – <p>If it is set to None samples will be equally weighted.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
<li><p><strong>return_sum_weights</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <p>If True, returns the sum of weights seen for each feature.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>means</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise means</p></li>
<li><p><strong>variances</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise variances</p></li>
<li><p><strong>sum_weights</strong> (<em>ndarray of shape (n_features,), dtype=floating</em>) – Returned if return_sum_weights is True.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id17">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">csr_row_norms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id17" title="Permalink to this definition">¶</a></dt>
<dd><p>L2 norm of each row in CSR matrix X.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id18">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">incr_mean_variance_axis0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id18" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance along axis 0 on a CSR or CSC matrix.</p>
<p>last_mean, last_var are the statistics computed at the last step by this
function. Both must be initialized to 0.0. last_n is the
number of samples encountered until now and is initialized at 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>CSR</em><em> or </em><em>CSC sparse matrix</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data.</p></li>
<li><p><strong>last_mean</strong> (<em>float array with shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em>) – Array of feature-wise means to update with the new data X.</p></li>
<li><p><strong>last_var</strong> (<em>float array with shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em>) – Array of feature-wise var to update with the new data X.</p></li>
<li><p><strong>last_n</strong> (<em>float array with shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em>) – Sum of the weights seen so far (if weights are all set to 1
this will be the same as number of samples seen so far, before X).</p></li>
<li><p><strong>weights</strong> (<em>float array with shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or </em><em>None. If it is set</em>) – to None samples will be equally weighted.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>updated_mean</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise means</p></li>
<li><p><strong>updated_variance</strong> (<em>float array with shape (n_features,)</em>) – Feature-wise variances</p></li>
<li><p><strong>updated_n</strong> (<em>int array with shape (n_features,)</em>) – Updated number of samples seen</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>NaNs are ignored during the computation.</p>
<p class="rubric">References</p>
<ol class="upperalpha simple" start="20">
<li><p>Chan, G. Golub, R. LeVeque. Algorithms for computing the sample</p></li>
</ol>
<blockquote>
<div><p>variance: recommendations, The American Statistician, Vol. 37, No. 3,
pp. 242-247</p>
</div></blockquote>
<p>Also, see the non-sparse implementation of this in
<cite>utils.extmath._batch_mean_variance_update</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id19">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">inplace_csr_row_normalize_l1</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id19" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace row normalize using the l1 norm</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id20">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.sparsefuncs_fast.</span></span><span class="sig-name descname"><span class="pre">inplace_csr_row_normalize_l2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id20" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace row normalize using the l2 norm</p>
</dd></dl>

</section>
<section id="module-sklearn.utils.stats">
<span id="sklearn-utils-stats-module"></span><h2>sklearn.utils.stats module<a class="headerlink" href="#module-sklearn.utils.stats" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-sklearn.utils.validation">
<span id="sklearn-utils-validation-module"></span><h2>sklearn.utils.validation module<a class="headerlink" href="#module-sklearn.utils.validation" title="Permalink to this headline">¶</a></h2>
<p>Utilities for input validation</p>
<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.as_float_array">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">as_float_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_all_finite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.as_float_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an array-like to an array of floats.</p>
<p>The new dtype will be np.float32 or np.float64, depending on the original
type. The function can create a copy or modify the argument depending
on the argument copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em>) – </p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True, a copy of X will be created. If False, a copy may still be
returned if X’s dtype is not a floating point type.</p></li>
<li><p><strong>force_all_finite</strong> (<em>bool</em><em> or </em><em>'allow-nan'</em><em>, </em><em>default=True</em>) – <p>Whether to raise an error on np.inf, np.nan, pd.NA in X. The
possibilities are:</p>
<ul>
<li><p>True: Force all values of X to be finite.</p></li>
<li><p>False: accepts np.inf, np.nan, pd.NA in X.</p></li>
<li><p>’allow-nan’: accepts only np.nan and pd.NA values in X. Values cannot
be infinite.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span><code class="docutils literal notranslate"><span class="pre">force_all_finite</span></code> accepts the string <code class="docutils literal notranslate"><span class="pre">'allow-nan'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23: </span>Accepts <cite>pd.NA</cite> and converts it into <cite>np.nan</cite></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>XT</strong> – An array of type float.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{ndarray, sparse matrix}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.assert_all_finite">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">assert_all_finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.assert_all_finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Throw a ValueError if X contains NaN or infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{ndarray</em><em>, </em><em>sparse matrix}</em>) – </p></li>
<li><p><strong>allow_nan</strong> (<em>bool</em><em>, </em><em>default=False</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.check_X_y">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">check_X_y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_large_sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numeric'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_all_finite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_2d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_nd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multi_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_min_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_min_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_numeric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.check_X_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Input validation for standard estimators.</p>
<p>Checks X and y for consistent length, enforces X to be 2D and y 1D. By
default, X is checked to be non-empty and containing only finite values.
Standard input checks are also applied to y, such as checking that y
does not have np.nan or np.inf targets. For multi-label y, set
multi_output=True to allow 2D and sparse y. If the dtype of X is
object, attempt converting to float, raising on failure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{ndarray</em><em>, </em><em>list</em><em>, </em><em>sparse matrix}</em>) – Input data.</p></li>
<li><p><strong>y</strong> (<em>{ndarray</em><em>, </em><em>list</em><em>, </em><em>sparse matrix}</em>) – Labels.</p></li>
<li><p><strong>accept_sparse</strong> (<em>str</em><em>, </em><em>bool</em><em> or </em><em>list of str</em><em>, </em><em>default=False</em>) – String[s] representing allowed sparse matrix formats, such as ‘csc’,
‘csr’, etc. If the input is sparse but not in the allowed format,
it will be converted to the first listed format. True allows the input
to be any format. False means that a sparse matrix input will
raise an error.</p></li>
<li><p><strong>accept_large_sparse</strong> (<em>bool</em><em>, </em><em>default=True</em>) – <p>If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
accept_sparse, accept_large_sparse will cause it to be accepted only
if its indices are stored with a 32-bit dtype.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
</p></li>
<li><p><strong>dtype</strong> (<em>'numeric'</em><em>, </em><em>type</em><em>, </em><em>list of type</em><em> or </em><em>None</em><em>, </em><em>default='numeric'</em>) – Data type of result. If None, the dtype of the input is preserved.
If “numeric”, dtype is preserved unless array.dtype is object.
If dtype is a list of types, conversion on the first type is only
performed if the dtype of the input is not in the list.</p></li>
<li><p><strong>order</strong> (<em>{'F'</em><em>, </em><em>'C'}</em><em>, </em><em>default=None</em>) – Whether an array will be forced to be fortran or c-style.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether a forced copy will be triggered. If copy=False, a copy might
be triggered by a conversion.</p></li>
<li><p><strong>force_all_finite</strong> (<em>bool</em><em> or </em><em>'allow-nan'</em><em>, </em><em>default=True</em>) – <p>Whether to raise an error on np.inf, np.nan, pd.NA in X. This parameter
does not influence whether y can have np.inf, np.nan, pd.NA values.
The possibilities are:</p>
<ul>
<li><p>True: Force all values of X to be finite.</p></li>
<li><p>False: accepts np.inf, np.nan, pd.NA in X.</p></li>
<li><p>’allow-nan’: accepts only np.nan or pd.NA values in X. Values cannot
be infinite.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span><code class="docutils literal notranslate"><span class="pre">force_all_finite</span></code> accepts the string <code class="docutils literal notranslate"><span class="pre">'allow-nan'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23: </span>Accepts <cite>pd.NA</cite> and converts it into <cite>np.nan</cite></p>
</div>
</p></li>
<li><p><strong>ensure_2d</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to raise a value error if X is not 2D.</p></li>
<li><p><strong>allow_nd</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to allow X.ndim &gt; 2.</p></li>
<li><p><strong>multi_output</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to allow 2D y (array or sparse matrix). If false, y will be
validated as a vector. y cannot have np.nan or np.inf values if
multi_output=True.</p></li>
<li><p><strong>ensure_min_samples</strong> (<em>int</em><em>, </em><em>default=1</em>) – Make sure that X has a minimum number of samples in its first
axis (rows for a 2D array).</p></li>
<li><p><strong>ensure_min_features</strong> (<em>int</em><em>, </em><em>default=1</em>) – Make sure that the 2D array has some minimum number of features
(columns). The default value of 1 rejects empty datasets.
This check is only enforced when X has effectively 2 dimensions or
is originally 1D and <code class="docutils literal notranslate"><span class="pre">ensure_2d</span></code> is True. Setting to 0 disables
this check.</p></li>
<li><p><strong>y_numeric</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to ensure that y has a numeric type. If dtype of y is object,
it is converted to float64. Should only be used for regression
algorithms.</p></li>
<li><p><strong>estimator</strong> (<em>str</em><em> or </em><em>estimator instance</em><em>, </em><em>default=None</em>) – If passed, include the name of the estimator in warning messages.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>X_converted</strong> (<em>object</em>) – The converted and validated X.</p></li>
<li><p><strong>y_converted</strong> (<em>object</em>) – The converted and validated y.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.check_array">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">check_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_large_sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numeric'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_all_finite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_2d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_nd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_min_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_min_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.check_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Input validation on an array, list, sparse matrix or similar.</p>
<p>By default, the input is checked to be a non-empty 2D array containing
only finite values. If the dtype of the array is object, attempt
converting to float, raising on failure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>object</em>) – Input object to check / convert.</p></li>
<li><p><strong>accept_sparse</strong> (<em>str</em><em>, </em><em>bool</em><em> or </em><em>list/tuple of str</em><em>, </em><em>default=False</em>) – String[s] representing allowed sparse matrix formats, such as ‘csc’,
‘csr’, etc. If the input is sparse but not in the allowed format,
it will be converted to the first listed format. True allows the input
to be any format. False means that a sparse matrix input will
raise an error.</p></li>
<li><p><strong>accept_large_sparse</strong> (<em>bool</em><em>, </em><em>default=True</em>) – <p>If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
accept_sparse, accept_large_sparse=False will cause it to be accepted
only if its indices are stored with a 32-bit dtype.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
</p></li>
<li><p><strong>dtype</strong> (<em>'numeric'</em><em>, </em><em>type</em><em>, </em><em>list of type</em><em> or </em><em>None</em><em>, </em><em>default='numeric'</em>) – Data type of result. If None, the dtype of the input is preserved.
If “numeric”, dtype is preserved unless array.dtype is object.
If dtype is a list of types, conversion on the first type is only
performed if the dtype of the input is not in the list.</p></li>
<li><p><strong>order</strong> (<em>{'F'</em><em>, </em><em>'C'}</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) – Whether an array will be forced to be fortran or c-style.
When order is None (default), then if copy=False, nothing is ensured
about the memory layout of the output array; otherwise (copy=True)
the memory layout of the returned array is kept as close as possible
to the original array.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether a forced copy will be triggered. If copy=False, a copy might
be triggered by a conversion.</p></li>
<li><p><strong>force_all_finite</strong> (<em>bool</em><em> or </em><em>'allow-nan'</em><em>, </em><em>default=True</em>) – <p>Whether to raise an error on np.inf, np.nan, pd.NA in array. The
possibilities are:</p>
<ul>
<li><p>True: Force all values of array to be finite.</p></li>
<li><p>False: accepts np.inf, np.nan, pd.NA in array.</p></li>
<li><p>’allow-nan’: accepts only np.nan and pd.NA values in array. Values
cannot be infinite.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span><code class="docutils literal notranslate"><span class="pre">force_all_finite</span></code> accepts the string <code class="docutils literal notranslate"><span class="pre">'allow-nan'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23: </span>Accepts <cite>pd.NA</cite> and converts it into <cite>np.nan</cite></p>
</div>
</p></li>
<li><p><strong>ensure_2d</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to raise a value error if array is not 2D.</p></li>
<li><p><strong>allow_nd</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to allow array.ndim &gt; 2.</p></li>
<li><p><strong>ensure_min_samples</strong> (<em>int</em><em>, </em><em>default=1</em>) – Make sure that the array has a minimum number of samples in its first
axis (rows for a 2D array). Setting to 0 disables this check.</p></li>
<li><p><strong>ensure_min_features</strong> (<em>int</em><em>, </em><em>default=1</em>) – Make sure that the 2D array has some minimum number of features
(columns). The default value of 1 rejects empty datasets.
This check is only enforced when the input data has effectively 2
dimensions or is originally 1D and <code class="docutils literal notranslate"><span class="pre">ensure_2d</span></code> is True. Setting to 0
disables this check.</p></li>
<li><p><strong>estimator</strong> (<em>str</em><em> or </em><em>estimator instance</em><em>, </em><em>default=None</em>) – If passed, include the name of the estimator in warning messages.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>array_converted</strong> – The converted and validated array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.check_consistent_length">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">check_consistent_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arrays</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.check_consistent_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that all arrays have consistent first dimensions.</p>
<p>Checks whether all objects in arrays have the same shape or length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*arrays</strong> (<em>list</em><em> or </em><em>tuple of input objects.</em>) – Objects that will be checked for consistent length.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.check_is_fitted">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">check_is_fitted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">estimator</span></em>, <em class="sig-param"><span class="pre">attributes=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">msg=None</span></em>, <em class="sig-param"><span class="pre">all_or_any=&lt;built-in</span> <span class="pre">function</span> <span class="pre">all&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.check_is_fitted" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform is_fitted validation for estimator.</p>
<p>Checks if the estimator is fitted by verifying the presence of
fitted attributes (ending with a trailing underscore) and otherwise
raises a NotFittedError with the given message.</p>
<p>This utility is meant to be used internally by estimators themselves,
typically in their own predict / transform methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> (<em>estimator instance</em>) – estimator instance for which the check is performed.</p></li>
<li><p><strong>attributes</strong> (<em>str</em><em>, </em><em>list</em><em> or </em><em>tuple of str</em><em>, </em><em>default=None</em>) – <p>Attribute name(s) given as string or a list/tuple of strings
Eg.: <code class="docutils literal notranslate"><span class="pre">[&quot;coef_&quot;,</span> <span class="pre">&quot;estimator_&quot;,</span> <span class="pre">...],</span> <span class="pre">&quot;coef_&quot;</span></code></p>
<p>If <cite>None</cite>, <cite>estimator</cite> is considered fitted if there exist an
attribute that ends with a underscore and does not start with double
underscore.</p>
</p></li>
<li><p><strong>msg</strong> (<em>str</em><em>, </em><em>default=None</em>) – <p>The default error message is, “This %(name)s instance is not fitted
yet. Call ‘fit’ with appropriate arguments before using this
estimator.”</p>
<p>For custom messages if “%(name)s” is present in the message string,
it is substituted for the estimator name.</p>
<p>Eg. : “Estimator, %(name)s, must be fitted before sparsifying”.</p>
</p></li>
<li><p><strong>all_or_any</strong> (<em>callable</em><em>, </em><em>{all</em><em>, </em><em>any}</em><em>, </em><em>default=all</em>) – Specify whether all or any of the given attributes must exist.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotFittedError</strong> – If the attributes are not found.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.check_memory">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">check_memory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.check_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that <code class="docutils literal notranslate"><span class="pre">memory</span></code> is joblib.Memory-like.</p>
<p>joblib.Memory-like means that <code class="docutils literal notranslate"><span class="pre">memory</span></code> can be converted into a
joblib.Memory instance (typically a str denoting the <code class="docutils literal notranslate"><span class="pre">location</span></code>)
or has the same interface (has a <code class="docutils literal notranslate"><span class="pre">cache</span></code> method).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>memory</strong> (<em>None</em><em>, </em><em>str</em><em> or </em><em>object with the joblib.Memory interface</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>memory</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object with the joblib.Memory interface</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">memory</span></code> is not joblib.Memory-like.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.check_non_negative">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">check_non_negative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.check_non_negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there is any negative value in an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em>) – Input data.</p></li>
<li><p><strong>whom</strong> (<em>str</em>) – Who passed X to this function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.check_random_state">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">check_random_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.check_random_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn seed into a np.random.RandomState instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> (<em>None</em><em>, </em><em>int</em><em> or </em><em>instance of RandomState</em>) – If seed is None, return the RandomState singleton used by np.random.
If seed is an int, return a new RandomState instance seeded with seed.
If seed is already a RandomState instance, return it.
Otherwise raise ValueError.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.check_scalar">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">check_scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_type</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.check_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate scalar parameters type and value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>object</em>) – The scalar parameter to validate.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – The name of the parameter to be printed in error messages.</p></li>
<li><p><strong>target_type</strong> (<em>type</em><em> or </em><em>tuple</em>) – Acceptable data types for the parameter.</p></li>
<li><p><strong>min_val</strong> (<em>float</em><em> or </em><em>int</em><em>, </em><em>default=None</em>) – The minimum valid value the parameter can take. If None (default) it
is implied that the parameter does not have a lower bound.</p></li>
<li><p><strong>max_val</strong> (<em>float</em><em> or </em><em>int</em><em>, </em><em>default=None</em>) – The maximum valid value the parameter can take. If None (default) it
is implied that the parameter does not have an upper bound.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the parameter’s type does not match the desired type.</p></li>
<li><p><strong>ValueError</strong> – If the parameter’s value violates the given bounds.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.check_symmetric">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">check_symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_warning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_exception</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.check_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure that array is 2D, square and symmetric.</p>
<p>If the array is not symmetric, then a symmetrized version is returned.
Optionally, a warning or exception is raised if the matrix is not
symmetric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>{ndarray</em><em>, </em><em>sparse matrix}</em>) – Input object to check / convert. Must be two-dimensional and square,
otherwise a ValueError will be raised.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>default=1e-10</em>) – Absolute tolerance for equivalence of arrays. Default = 1E-10.</p></li>
<li><p><strong>raise_warning</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True then raise a warning if conversion is required.</p></li>
<li><p><strong>raise_exception</strong> (<em>bool</em><em>, </em><em>default=False</em>) – If True then raise an exception if array is not symmetric.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>array_sym</strong> – Symmetrized version of the input array, i.e. the average of array
and array.transpose(). If sparse, then duplicate entries are first
summed and zeros are eliminated.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{ndarray, sparse matrix}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.column_or_1d">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">column_or_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.column_or_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Ravel column or 1d numpy array, else raises an error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>array-like</em>) – </p></li>
<li><p><strong>warn</strong> (<em>bool</em><em>, </em><em>default=False</em>) – To control display of warnings.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.has_fit_parameter">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">has_fit_parameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.has_fit_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the estimator’s fit method supports the given parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> (<em>object</em>) – An estimator to inspect.</p></li>
<li><p><strong>parameter</strong> (<em>str</em>) – The searched parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>is_parameter</strong> – Whether the parameter was found to be a named parameter of the
estimator’s fit method.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">has_fit_parameter</span><span class="p">(</span><span class="n">SVC</span><span class="p">(),</span> <span class="s2">&quot;sample_weight&quot;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.validation.indexable">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.validation.</span></span><span class="sig-name descname"><span class="pre">indexable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">iterables</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.validation.indexable" title="Permalink to this definition">¶</a></dt>
<dd><p>Make arrays indexable for cross-validation.</p>
<p>Checks consistent length, passes through None, and ensures that everything
can be indexed by converting sparse matrices to csr and converting
non-interable objects to arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*iterables</strong> (<em>{lists</em><em>, </em><em>dataframes</em><em>, </em><em>ndarrays</em><em>, </em><em>sparse matrices}</em>) – List of objects to ensure sliceability.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-sklearn.utils">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-sklearn.utils" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-sklearn.utils" title="sklearn.utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.utils</span></code></a> module includes various utilities.</p>
<dl class="py exception">
<dt class="sig sig-object py" id="sklearn.utils.DataConversionWarning">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">DataConversionWarning</span></span><a class="headerlink" href="#sklearn.utils.DataConversionWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">UserWarning</span></code></p>
<p>Warning used to notify implicit data conversions happening in the code.</p>
<p>This warning occurs when some input data needs to be converted or
interpreted in a way that may not match the user’s expectations.</p>
<dl class="simple">
<dt>For example, this warning may occur when the user</dt><dd><ul class="simple">
<li><p>passes an integer array to a function which expects float input and
will convert the input</p></li>
<li><p>requests a non-copying operation, but a copy is required to meet the
implementation’s data-type expectations;</p></li>
<li><p>passes an input whose shape can be interpreted ambiguously.</p></li>
</ul>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18: </span>Moved from sklearn.utils.validation.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.all_estimators">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">all_estimators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.all_estimators" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of all estimators from sklearn.</p>
<p>This function crawls the module and gets all classes that inherit
from BaseEstimator. Classes that are defined in test-modules are not
included.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>type_filter</strong> (<em>{&quot;classifier&quot;</em><em>, </em><em>&quot;regressor&quot;</em><em>, </em><em>&quot;cluster&quot;</em><em>, </em><em>&quot;transformer&quot;}</em><em>             or </em><em>list of such str</em><em>, </em><em>default=None</em>) – Which kind of estimators should be returned. If None, no filter is
applied and all estimators are returned.  Possible values are
‘classifier’, ‘regressor’, ‘cluster’ and ‘transformer’ to get
estimators only of these specific types, or a list of these to
get the estimators that fit at least one of the types.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>estimators</strong> – List of (name, class), where <code class="docutils literal notranslate"><span class="pre">name</span></code> is the class name as string
and <code class="docutils literal notranslate"><span class="pre">class</span></code> is the actuall type of the class.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of tuples</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.as_float_array">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">as_float_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_all_finite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.as_float_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an array-like to an array of floats.</p>
<p>The new dtype will be np.float32 or np.float64, depending on the original
type. The function can create a copy or modify the argument depending
on the argument copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em>) – </p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True, a copy of X will be created. If False, a copy may still be
returned if X’s dtype is not a floating point type.</p></li>
<li><p><strong>force_all_finite</strong> (<em>bool</em><em> or </em><em>'allow-nan'</em><em>, </em><em>default=True</em>) – <p>Whether to raise an error on np.inf, np.nan, pd.NA in X. The
possibilities are:</p>
<ul>
<li><p>True: Force all values of X to be finite.</p></li>
<li><p>False: accepts np.inf, np.nan, pd.NA in X.</p></li>
<li><p>’allow-nan’: accepts only np.nan and pd.NA values in X. Values cannot
be infinite.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span><code class="docutils literal notranslate"><span class="pre">force_all_finite</span></code> accepts the string <code class="docutils literal notranslate"><span class="pre">'allow-nan'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23: </span>Accepts <cite>pd.NA</cite> and converts it into <cite>np.nan</cite></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>XT</strong> – An array of type float.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{ndarray, sparse matrix}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.assert_all_finite">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">assert_all_finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.assert_all_finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Throw a ValueError if X contains NaN or infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{ndarray</em><em>, </em><em>sparse matrix}</em>) – </p></li>
<li><p><strong>allow_nan</strong> (<em>bool</em><em>, </em><em>default=False</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.check_X_y">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">check_X_y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_large_sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numeric'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_all_finite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_2d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_nd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multi_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_min_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_min_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_numeric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.check_X_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Input validation for standard estimators.</p>
<p>Checks X and y for consistent length, enforces X to be 2D and y 1D. By
default, X is checked to be non-empty and containing only finite values.
Standard input checks are also applied to y, such as checking that y
does not have np.nan or np.inf targets. For multi-label y, set
multi_output=True to allow 2D and sparse y. If the dtype of X is
object, attempt converting to float, raising on failure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{ndarray</em><em>, </em><em>list</em><em>, </em><em>sparse matrix}</em>) – Input data.</p></li>
<li><p><strong>y</strong> (<em>{ndarray</em><em>, </em><em>list</em><em>, </em><em>sparse matrix}</em>) – Labels.</p></li>
<li><p><strong>accept_sparse</strong> (<em>str</em><em>, </em><em>bool</em><em> or </em><em>list of str</em><em>, </em><em>default=False</em>) – String[s] representing allowed sparse matrix formats, such as ‘csc’,
‘csr’, etc. If the input is sparse but not in the allowed format,
it will be converted to the first listed format. True allows the input
to be any format. False means that a sparse matrix input will
raise an error.</p></li>
<li><p><strong>accept_large_sparse</strong> (<em>bool</em><em>, </em><em>default=True</em>) – <p>If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
accept_sparse, accept_large_sparse will cause it to be accepted only
if its indices are stored with a 32-bit dtype.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
</p></li>
<li><p><strong>dtype</strong> (<em>'numeric'</em><em>, </em><em>type</em><em>, </em><em>list of type</em><em> or </em><em>None</em><em>, </em><em>default='numeric'</em>) – Data type of result. If None, the dtype of the input is preserved.
If “numeric”, dtype is preserved unless array.dtype is object.
If dtype is a list of types, conversion on the first type is only
performed if the dtype of the input is not in the list.</p></li>
<li><p><strong>order</strong> (<em>{'F'</em><em>, </em><em>'C'}</em><em>, </em><em>default=None</em>) – Whether an array will be forced to be fortran or c-style.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether a forced copy will be triggered. If copy=False, a copy might
be triggered by a conversion.</p></li>
<li><p><strong>force_all_finite</strong> (<em>bool</em><em> or </em><em>'allow-nan'</em><em>, </em><em>default=True</em>) – <p>Whether to raise an error on np.inf, np.nan, pd.NA in X. This parameter
does not influence whether y can have np.inf, np.nan, pd.NA values.
The possibilities are:</p>
<ul>
<li><p>True: Force all values of X to be finite.</p></li>
<li><p>False: accepts np.inf, np.nan, pd.NA in X.</p></li>
<li><p>’allow-nan’: accepts only np.nan or pd.NA values in X. Values cannot
be infinite.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span><code class="docutils literal notranslate"><span class="pre">force_all_finite</span></code> accepts the string <code class="docutils literal notranslate"><span class="pre">'allow-nan'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23: </span>Accepts <cite>pd.NA</cite> and converts it into <cite>np.nan</cite></p>
</div>
</p></li>
<li><p><strong>ensure_2d</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to raise a value error if X is not 2D.</p></li>
<li><p><strong>allow_nd</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to allow X.ndim &gt; 2.</p></li>
<li><p><strong>multi_output</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to allow 2D y (array or sparse matrix). If false, y will be
validated as a vector. y cannot have np.nan or np.inf values if
multi_output=True.</p></li>
<li><p><strong>ensure_min_samples</strong> (<em>int</em><em>, </em><em>default=1</em>) – Make sure that X has a minimum number of samples in its first
axis (rows for a 2D array).</p></li>
<li><p><strong>ensure_min_features</strong> (<em>int</em><em>, </em><em>default=1</em>) – Make sure that the 2D array has some minimum number of features
(columns). The default value of 1 rejects empty datasets.
This check is only enforced when X has effectively 2 dimensions or
is originally 1D and <code class="docutils literal notranslate"><span class="pre">ensure_2d</span></code> is True. Setting to 0 disables
this check.</p></li>
<li><p><strong>y_numeric</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to ensure that y has a numeric type. If dtype of y is object,
it is converted to float64. Should only be used for regression
algorithms.</p></li>
<li><p><strong>estimator</strong> (<em>str</em><em> or </em><em>estimator instance</em><em>, </em><em>default=None</em>) – If passed, include the name of the estimator in warning messages.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>X_converted</strong> (<em>object</em>) – The converted and validated X.</p></li>
<li><p><strong>y_converted</strong> (<em>object</em>) – The converted and validated y.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.check_array">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">check_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accept_large_sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numeric'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_all_finite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_2d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_nd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_min_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_min_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.check_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Input validation on an array, list, sparse matrix or similar.</p>
<p>By default, the input is checked to be a non-empty 2D array containing
only finite values. If the dtype of the array is object, attempt
converting to float, raising on failure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>object</em>) – Input object to check / convert.</p></li>
<li><p><strong>accept_sparse</strong> (<em>str</em><em>, </em><em>bool</em><em> or </em><em>list/tuple of str</em><em>, </em><em>default=False</em>) – String[s] representing allowed sparse matrix formats, such as ‘csc’,
‘csr’, etc. If the input is sparse but not in the allowed format,
it will be converted to the first listed format. True allows the input
to be any format. False means that a sparse matrix input will
raise an error.</p></li>
<li><p><strong>accept_large_sparse</strong> (<em>bool</em><em>, </em><em>default=True</em>) – <p>If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
accept_sparse, accept_large_sparse=False will cause it to be accepted
only if its indices are stored with a 32-bit dtype.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
</p></li>
<li><p><strong>dtype</strong> (<em>'numeric'</em><em>, </em><em>type</em><em>, </em><em>list of type</em><em> or </em><em>None</em><em>, </em><em>default='numeric'</em>) – Data type of result. If None, the dtype of the input is preserved.
If “numeric”, dtype is preserved unless array.dtype is object.
If dtype is a list of types, conversion on the first type is only
performed if the dtype of the input is not in the list.</p></li>
<li><p><strong>order</strong> (<em>{'F'</em><em>, </em><em>'C'}</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) – Whether an array will be forced to be fortran or c-style.
When order is None (default), then if copy=False, nothing is ensured
about the memory layout of the output array; otherwise (copy=True)
the memory layout of the returned array is kept as close as possible
to the original array.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether a forced copy will be triggered. If copy=False, a copy might
be triggered by a conversion.</p></li>
<li><p><strong>force_all_finite</strong> (<em>bool</em><em> or </em><em>'allow-nan'</em><em>, </em><em>default=True</em>) – <p>Whether to raise an error on np.inf, np.nan, pd.NA in array. The
possibilities are:</p>
<ul>
<li><p>True: Force all values of array to be finite.</p></li>
<li><p>False: accepts np.inf, np.nan, pd.NA in array.</p></li>
<li><p>’allow-nan’: accepts only np.nan and pd.NA values in array. Values
cannot be infinite.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span><code class="docutils literal notranslate"><span class="pre">force_all_finite</span></code> accepts the string <code class="docutils literal notranslate"><span class="pre">'allow-nan'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23: </span>Accepts <cite>pd.NA</cite> and converts it into <cite>np.nan</cite></p>
</div>
</p></li>
<li><p><strong>ensure_2d</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to raise a value error if array is not 2D.</p></li>
<li><p><strong>allow_nd</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to allow array.ndim &gt; 2.</p></li>
<li><p><strong>ensure_min_samples</strong> (<em>int</em><em>, </em><em>default=1</em>) – Make sure that the array has a minimum number of samples in its first
axis (rows for a 2D array). Setting to 0 disables this check.</p></li>
<li><p><strong>ensure_min_features</strong> (<em>int</em><em>, </em><em>default=1</em>) – Make sure that the 2D array has some minimum number of features
(columns). The default value of 1 rejects empty datasets.
This check is only enforced when the input data has effectively 2
dimensions or is originally 1D and <code class="docutils literal notranslate"><span class="pre">ensure_2d</span></code> is True. Setting to 0
disables this check.</p></li>
<li><p><strong>estimator</strong> (<em>str</em><em> or </em><em>estimator instance</em><em>, </em><em>default=None</em>) – If passed, include the name of the estimator in warning messages.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>array_converted</strong> – The converted and validated array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.check_consistent_length">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">check_consistent_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arrays</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.check_consistent_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that all arrays have consistent first dimensions.</p>
<p>Checks whether all objects in arrays have the same shape or length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*arrays</strong> (<em>list</em><em> or </em><em>tuple of input objects.</em>) – Objects that will be checked for consistent length.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.check_matplotlib_support">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">check_matplotlib_support</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">caller_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.check_matplotlib_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise ImportError with detailed error message if mpl is not installed.</p>
<p>Plot utilities like <code class="xref py py-func docutils literal notranslate"><span class="pre">plot_partial_dependence()</span></code> should lazily import
matplotlib and call this helper before any computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>caller_name</strong> (<em>str</em>) – The name of the caller that requires matplotlib.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.check_random_state">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">check_random_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.check_random_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn seed into a np.random.RandomState instance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> (<em>None</em><em>, </em><em>int</em><em> or </em><em>instance of RandomState</em>) – If seed is None, return the RandomState singleton used by np.random.
If seed is an int, return a new RandomState instance seeded with seed.
If seed is already a RandomState instance, return it.
Otherwise raise ValueError.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.check_scalar">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">check_scalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_type</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.check_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate scalar parameters type and value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>object</em>) – The scalar parameter to validate.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – The name of the parameter to be printed in error messages.</p></li>
<li><p><strong>target_type</strong> (<em>type</em><em> or </em><em>tuple</em>) – Acceptable data types for the parameter.</p></li>
<li><p><strong>min_val</strong> (<em>float</em><em> or </em><em>int</em><em>, </em><em>default=None</em>) – The minimum valid value the parameter can take. If None (default) it
is implied that the parameter does not have a lower bound.</p></li>
<li><p><strong>max_val</strong> (<em>float</em><em> or </em><em>int</em><em>, </em><em>default=None</em>) – The maximum valid value the parameter can take. If None (default) it
is implied that the parameter does not have an upper bound.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> – If the parameter’s type does not match the desired type.</p></li>
<li><p><strong>ValueError</strong> – If the parameter’s value violates the given bounds.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.check_symmetric">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">check_symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_warning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_exception</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.check_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure that array is 2D, square and symmetric.</p>
<p>If the array is not symmetric, then a symmetrized version is returned.
Optionally, a warning or exception is raised if the matrix is not
symmetric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>{ndarray</em><em>, </em><em>sparse matrix}</em>) – Input object to check / convert. Must be two-dimensional and square,
otherwise a ValueError will be raised.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>default=1e-10</em>) – Absolute tolerance for equivalence of arrays. Default = 1E-10.</p></li>
<li><p><strong>raise_warning</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True then raise a warning if conversion is required.</p></li>
<li><p><strong>raise_exception</strong> (<em>bool</em><em>, </em><em>default=False</em>) – If True then raise an exception if array is not symmetric.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>array_sym</strong> – Symmetrized version of the input array, i.e. the average of array
and array.transpose(). If sparse, then duplicate entries are first
summed and zeros are eliminated.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{ndarray, sparse matrix}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.column_or_1d">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">column_or_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.column_or_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Ravel column or 1d numpy array, else raises an error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>array-like</em>) – </p></li>
<li><p><strong>warn</strong> (<em>bool</em><em>, </em><em>default=False</em>) – To control display of warnings.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.compute_class_weight">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">compute_class_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_weight</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.compute_class_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate class weights for unbalanced datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_weight</strong> (<em>dict</em><em>, </em><em>'balanced'</em><em> or </em><em>None</em>) – If ‘balanced’, class weights will be given by
<code class="docutils literal notranslate"><span class="pre">n_samples</span> <span class="pre">/</span> <span class="pre">(n_classes</span> <span class="pre">*</span> <span class="pre">np.bincount(y))</span></code>.
If a dictionary is given, keys are classes and values
are corresponding class weights.
If None is given, the class weights will be uniform.</p></li>
<li><p><strong>classes</strong> (<em>ndarray</em>) – Array of the classes occurring in the data, as given by
<code class="docutils literal notranslate"><span class="pre">np.unique(y_org)</span></code> with <code class="docutils literal notranslate"><span class="pre">y_org</span></code> the original class labels.</p></li>
<li><p><strong>y</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em>) – Array of original class labels per sample.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>class_weight_vect</strong> – Array with class_weight_vect[i] the weight for i-th class.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_classes,)</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>The “balanced” heuristic is inspired by
Logistic Regression in Rare Events Data, King, Zen, 2001.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.compute_sample_weight">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">compute_sample_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.compute_sample_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate sample weights by class for unbalanced datasets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_weight</strong> (<em>dict</em><em>, </em><em>list of dicts</em><em>, </em><em>&quot;balanced&quot;</em><em>, or </em><em>None</em>) – <p>Weights associated with classes in the form <code class="docutils literal notranslate"><span class="pre">{class_label:</span> <span class="pre">weight}</span></code>.
If not given, all classes are supposed to have weight one. For
multi-output problems, a list of dicts can be provided in the same
order as the columns of y.</p>
<p>Note that for multioutput (including multilabel) weights should be
defined for each class of every column in its own dict. For example,
for four-class multilabel classification weights should be
[{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of
[{1:1}, {2:5}, {3:1}, {4:1}].</p>
<p>The “balanced” mode uses the values of y to automatically adjust
weights inversely proportional to class frequencies in the input data:
<code class="docutils literal notranslate"><span class="pre">n_samples</span> <span class="pre">/</span> <span class="pre">(n_classes</span> <span class="pre">*</span> <span class="pre">np.bincount(y))</span></code>.</p>
<p>For multi-output, the weights of each column of y will be multiplied.</p>
</p></li>
<li><p><strong>y</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or </em><em>(</em><em>n_samples</em><em>, </em><em>n_outputs</em><em>)</em>) – Array of original class labels per sample.</p></li>
<li><p><strong>indices</strong> (<em>array-like of shape</em><em> (</em><em>n_subsample</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – Array of indices to be used in a subsample. Can be of length less than
n_samples in the case of a subsample, or equal to n_samples in the
case of a bootstrap subsample with repeated indices. If None, the
sample weight will be calculated over the full sample. Only “balanced”
is supported for class_weight if this is provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sample_weight_vect</strong> – Array with sample weights as applied to the original y.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_samples,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sklearn.utils.deprecated">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">deprecated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.deprecated" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Decorator to mark a function or class as deprecated.</p>
<p>Issue a warning when the function is called/the class is instantiated and
adds a warning to the docstring.</p>
<p>The optional extra argument will be appended to the deprecation message
and the docstring. Note: to use this with the default value for extra, put
in an empty of parentheses:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deprecated</span><span class="p">()</span>
<span class="go">&lt;sklearn.utils.deprecation.deprecated object at ...&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@deprecated</span><span class="p">()</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">some_function</span><span class="p">():</span> <span class="k">pass</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>extra</strong> (<em>str</em><em>, </em><em>default=''</em>) – To be added to the deprecation messages.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.estimator_html_repr">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">estimator_html_repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.estimator_html_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a HTML representation of an estimator.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>estimator</strong> (<em>estimator object</em>) – The estimator to visualize.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>html</strong> – HTML representation of estimator.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.indexable">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">indexable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">iterables</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.indexable" title="Permalink to this definition">¶</a></dt>
<dd><p>Make arrays indexable for cross-validation.</p>
<p>Checks consistent length, passes through None, and ensures that everything
can be indexed by converting sparse matrices to csr and converting
non-interable objects to arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*iterables</strong> (<em>{lists</em><em>, </em><em>dataframes</em><em>, </em><em>ndarrays</em><em>, </em><em>sparse matrices}</em>) – List of objects to ensure sliceability.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.indices_to_mask">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">indices_to_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.indices_to_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert list of indices to boolean mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> (<em>list-like</em>) – List of integers treated as indices.</p></li>
<li><p><strong>mask_length</strong> (<em>int</em>) – Length of boolean mask to be generated.
This parameter must be greater than max(indices).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mask</strong> – Boolean array that is True where indices are present, else False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d boolean nd-array</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">indices_to_mask</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices_to_mask</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([False,  True,  True,  True,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sklearn.utils.parallel_backend">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">parallel_backend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_max_num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">backend_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.parallel_backend" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Change the default backend used by Parallel inside a with block.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">backend</span></code> is a string it must match a previously registered
implementation using the <code class="docutils literal notranslate"><span class="pre">register_parallel_backend</span></code> function.</p>
<p>By default the following backends are available:</p>
<ul class="simple">
<li><p>‘loky’: single-host, process-based parallelism (used by default),</p></li>
<li><p>‘threading’: single-host, thread-based parallelism,</p></li>
<li><p>‘multiprocessing’: legacy single-host, process-based parallelism.</p></li>
</ul>
<p>‘loky’ is recommended to run functions that manipulate Python objects.
‘threading’ is a low-overhead alternative that is most efficient for
functions that release the Global Interpreter Lock: e.g. I/O-bound code or
CPU-bound code in a few calls to native code that explicitly releases the
GIL.</p>
<p>In addition, if the <cite>dask</cite> and <cite>distributed</cite> Python packages are installed,
it is possible to use the ‘dask’ backend for better scheduling of nested
parallel calls without over-subscription and potentially distribute
parallel calls over a networked cluster of several hosts.</p>
<p>It is also possible to use the distributed ‘ray’ backend for distributing
the workload to a cluster of nodes. To use the ‘ray’ joblib backend add
the following lines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ray.util.joblib</span> <span class="kn">import</span> <span class="n">register_ray</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">register_ray</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">parallel_backend</span><span class="p">(</span><span class="s2">&quot;ray&quot;</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">Parallel</span><span class="p">()(</span><span class="n">delayed</span><span class="p">(</span><span class="n">neg</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="go">[-1, -2, -3, -4, -5]</span>
</pre></div>
</div>
<p>Alternatively the backend can be passed directly as an instance.</p>
<p>By default all available workers will be used (<code class="docutils literal notranslate"><span class="pre">n_jobs=-1</span></code>) unless the
caller passes an explicit value for the <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> parameter.</p>
<p>This is an alternative to passing a <code class="docutils literal notranslate"><span class="pre">backend='backend_name'</span></code> argument to
the <code class="docutils literal notranslate"><span class="pre">Parallel</span></code> class constructor. It is particularly useful when calling
into library code that uses joblib internally but does not expose the
backend argument in its own API.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">neg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">parallel_backend</span><span class="p">(</span><span class="s1">&#39;threading&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">Parallel</span><span class="p">()(</span><span class="n">delayed</span><span class="p">(</span><span class="n">neg</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">[-1, -2, -3, -4, -5]</span>
</pre></div>
</div>
<p>Warning: this function is experimental and subject to change in a future
version of joblib.</p>
<p>Joblib also tries to limit the oversubscription by limiting the number of
threads usable in some third-party library threadpools like OpenBLAS, MKL
or OpenMP. The default limit in each worker is set to
<code class="docutils literal notranslate"><span class="pre">max(cpu_count()</span> <span class="pre">//</span> <span class="pre">effective_n_jobs,</span> <span class="pre">1)</span></code> but this limit can be
overwritten with the <code class="docutils literal notranslate"><span class="pre">inner_max_num_threads</span></code> argument which will be used
to set this limit in the child processes.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.10.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sklearn.utils.parallel_backend.unregister">
<span class="sig-name descname"><span class="pre">unregister</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.parallel_backend.unregister" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.register_parallel_backend">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">register_parallel_backend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">make_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.register_parallel_backend" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a new Parallel backend factory.</p>
<p>The new backend can then be selected by passing its name as the backend
argument to the Parallel class. Moreover, the default backend can be
overwritten globally by setting make_default=True.</p>
<p>The factory can be any callable that takes no argument and return an
instance of <code class="docutils literal notranslate"><span class="pre">ParallelBackendBase</span></code>.</p>
<p>Warning: this function is experimental and subject to change in a future
version of joblib.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.10.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.resample">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arrays</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stratify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample arrays or sparse matrices in a consistent way.</p>
<p>The default strategy implements one step of the bootstrapping
procedure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*arrays</strong> (<em>sequence of array-like of shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or             </em><em>(</em><em>n_samples</em><em>, </em><em>n_outputs</em><em>)</em>) – Indexable data-structures can be arrays, lists, dataframes or scipy
sparse matrices with consistent first dimension.</p></li>
<li><p><strong>replace</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Implements resampling with replacement. If False, this will implement
(sliced) random permutations.</p></li>
<li><p><strong>n_samples</strong> (<em>int</em><em>, </em><em>default=None</em>) – Number of samples to generate. If left to None this is
automatically set to the first dimension of the arrays.
If replace is False it should not be larger than the length of
arrays.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) – Determines random number generation for shuffling
the data.
Pass an int for reproducible results across multiple function calls.
See <span class="xref std std-term">Glossary</span>.</p></li>
<li><p><strong>stratify</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or </em><em>(</em><em>n_samples</em><em>, </em><em>n_outputs</em><em>)</em><em>,             </em><em>default=None</em>) – If not None, data is split in a stratified fashion, using this as
the class labels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>resampled_arrays</strong> – Sequence of resampled copies of the collections. The original arrays
are not impacted.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sequence of array-like of shape (n_samples,) or             (n_samples, n_outputs)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>It is possible to mix sparse and dense arrays in the same run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">coo_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_sparse</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">resample</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">X_sparse</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_sparse</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">array([[1., 0.],</span>
<span class="go">       [2., 1.],</span>
<span class="go">       [1., 0.]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_sparse</span>
<span class="go">&lt;3x2 sparse matrix of type &#39;&lt;... &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="go">    with 4 stored elements in Compressed Sparse Row format&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_sparse</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[1., 0.],</span>
<span class="go">       [2., 1.],</span>
<span class="go">       [1., 0.]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([0, 1, 0])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
<p>Example using stratification:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resample</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
<span class="gp">... </span>         <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[1, 1, 1, 0, 1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sklearn.utils.shuffle" title="sklearn.utils.shuffle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shuffle</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sklearn.utils.shuffle">
<span class="sig-prename descclassname"><span class="pre">sklearn.utils.</span></span><span class="sig-name descname"><span class="pre">shuffle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arrays</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.utils.shuffle" title="Permalink to this definition">¶</a></dt>
<dd><p>Shuffle arrays or sparse matrices in a consistent way.</p>
<p>This is a convenience alias to <code class="docutils literal notranslate"><span class="pre">resample(*arrays,</span> <span class="pre">replace=False)</span></code> to do
random permutations of the collections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*arrays</strong> (<em>sequence of indexable data-structures</em>) – Indexable data-structures can be arrays, lists, dataframes or scipy
sparse matrices with consistent first dimension.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) – Determines random number generation for shuffling
the data.
Pass an int for reproducible results across multiple function calls.
See <span class="xref std std-term">Glossary</span>.</p></li>
<li><p><strong>n_samples</strong> (<em>int</em><em>, </em><em>default=None</em>) – Number of samples to generate. If left to None this is
automatically set to the first dimension of the arrays.  It should
not be larger than the length of arrays.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>shuffled_arrays</strong> – Sequence of shuffled copies of the collections. The original arrays
are not impacted.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sequence of indexable data-structures</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>It is possible to mix sparse and dense arrays in the same run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">coo_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_sparse</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">shuffle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">X_sparse</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_sparse</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">array([[0., 0.],</span>
<span class="go">       [2., 1.],</span>
<span class="go">       [1., 0.]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_sparse</span>
<span class="go">&lt;3x2 sparse matrix of type &#39;&lt;... &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="go">    with 3 stored elements in Compressed Sparse Row format&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X_sparse</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[0., 0.],</span>
<span class="go">       [2., 1.],</span>
<span class="go">       [1., 0.]])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([2, 1, 0])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">shuffle</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sklearn.utils.resample" title="sklearn.utils.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a></p>
</div>
</dd></dl>

</section>
</section>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Tommaso Fioravanti

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>