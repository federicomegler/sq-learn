

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>q_Pca &mdash; sqlearn  documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="q_utilities" href="sklearn.QuantumUtility.html" />
    <link rel="prev" title="q_means" href="sklearn.cluster.html" />
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> sqlearn
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Getting started</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="sklearn.html">sqlearn package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="sklearn.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="sklearn.cluster.html">q_means</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">q_Pca</a></li>
<li class="toctree-l4"><a class="reference internal" href="sklearn.QuantumUtility.html">q_utilities</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modules.html#requirements">Requirements</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">sqlearn</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">Getting started</a> &raquo;</li>
        
          <li><a href="sklearn.html">sqlearn package</a> &raquo;</li>
        
      <li>q_Pca</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/tommasofioravanti/SafeStreet/blob/sklearn.decomposition.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="q-pca">
<h1>q_Pca<a class="headerlink" href="#q-pca" title="Permalink to this headline">¶</a></h1>
<section id="module-sklearn.decomposition">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-sklearn.decomposition" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-sklearn.decomposition" title="sklearn.decomposition"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.decomposition</span></code></a> module includes matrix decomposition
algorithms, including among others PCA, NMF or ICA. Most of the algorithms of
this module can be regarded as dimensionality reduction techniques. This sqlearn
framework include also the quantum implementation of the PCA model.</p>
<dl class="py class">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">qPCA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">whiten</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">svd_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterated_power</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.decomposition.qPCA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.decomposition._base._BasePCA</span></code></p>
<p>Quantum Principal component analysis (qPCA).</p>
<p>Linear dimensionality reduction using Singular Value Decomposition of the
data to project it to a lower dimensional space. The input data is centered
but not scaled for each feature before applying the SVD.</p>
<p>It uses the LAPACK implementation of the full SVD or a randomized truncated
SVD by the method of Halko et al. 2009, depending on the shape of the input
data and the number of components to extract.</p>
<p>It can also use the scipy.sparse.linalg ARPACK implementation of the
truncated SVD.</p>
<p>Notice that this class does not support sparse input. See
<code class="xref py py-class docutils literal notranslate"><span class="pre">TruncatedSVD</span></code> for an alternative with sparse data.</p>
<p>Notice also that the quantum routines are implemented only for the ‘full’ svd_solver case.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_components</strong> (<em>int</em><em>, </em><em>float</em><em> or </em><em>'mle'</em><em>, </em><em>default=None</em>) – <p>Number of components to keep.
if n_components is not set all components are kept:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_components</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">n_components</span> <span class="pre">==</span> <span class="pre">'mle'</span></code> and <code class="docutils literal notranslate"><span class="pre">svd_solver</span> <span class="pre">==</span> <span class="pre">'full'</span></code>, Minka’s
MLE is used to guess the dimension. Use of <code class="docutils literal notranslate"><span class="pre">n_components</span> <span class="pre">==</span> <span class="pre">'mle'</span></code>
will interpret <code class="docutils literal notranslate"><span class="pre">svd_solver</span> <span class="pre">==</span> <span class="pre">'auto'</span></code> as <code class="docutils literal notranslate"><span class="pre">svd_solver</span> <span class="pre">==</span> <span class="pre">'full'</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">n_components</span> <span class="pre">&lt;</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">svd_solver</span> <span class="pre">==</span> <span class="pre">'full'</span></code>, select the
number of components such that the amount of variance that needs to be
explained is greater than the percentage specified by n_components.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">svd_solver</span> <span class="pre">==</span> <span class="pre">'arpack'</span></code>, the number of components must be
strictly less than the minimum of n_features and n_samples.</p>
<p>Hence, the None case results in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_components</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div>
</div>
</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If False, data passed to fit are overwritten and running
fit(X).transform(X) will not yield the expected results,
use fit_transform(X) instead.</p></li>
<li><p><strong>whiten</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <p>When True (False by default) the <cite>components_</cite> vectors are multiplied
by the square root of n_samples and then divided by the singular values
to ensure uncorrelated outputs with unit component-wise variances.</p>
<p>Whitening will remove some information from the transformed signal
(the relative variance scales of the components) but can sometime
improve the predictive accuracy of the downstream estimators by
making their data respect some hard-wired assumptions.</p>
</p></li>
<li><p><strong>svd_solver</strong> (<em>{'auto'</em><em>, </em><em>'full'</em><em>, </em><em>'arpack'</em><em>, </em><em>'randomized'}</em><em>, </em><em>default='auto'</em>) – <dl class="simple">
<dt>If auto :</dt><dd><p>The solver is selected by a default policy based on <cite>X.shape</cite> and
<cite>n_components</cite>: if the input data is larger than 500x500 and the
number of components to extract is lower than 80% of the smallest
dimension of the data, then the more efficient ‘randomized’
method is enabled. Otherwise the exact full SVD is computed and
optionally truncated afterwards.</p>
</dd>
<dt>If full :</dt><dd><p>run exact full SVD calling the standard LAPACK solver via
<cite>scipy.linalg.svd</cite> and select the components by postprocessing</p>
</dd>
<dt>If arpack :</dt><dd><p>run SVD truncated to n_components calling ARPACK solver via
<cite>scipy.sparse.linalg.svds</cite>. It requires strictly
0 &lt; n_components &lt; min(X.shape)</p>
</dd>
<dt>If randomized :</dt><dd><p>run randomized SVD by the method of Halko et al.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.0.</span></p>
</div>
</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>default=0.0</em>) – <p>Tolerance for singular values computed by svd_solver == ‘arpack’.
Must be of range [0.0, infinity).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.0.</span></p>
</div>
</p></li>
<li><p><strong>iterated_power</strong> (<em>int</em><em> or </em><em>'auto'</em><em>, </em><em>default='auto'</em>) – <p>Number of iterations for the power method computed by
svd_solver == ‘randomized’.
Must be of range [0, infinity).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.0.</span></p>
</div>
</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) – <p>Used when the ‘arpack’ or ‘randomized’ solvers are used. Pass an int
for reproducible results across multiple function calls.
See <span class="xref std std-term">Glossary</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.0.</span></p>
</div>
</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.components_">
<span class="sig-name descname"><span class="pre">components_</span></span><a class="headerlink" href="#sklearn.decomposition.qPCA.components_" title="Permalink to this definition">¶</a></dt>
<dd><p>Principal axes in feature space, representing the directions of
maximum variance in the data. The components are sorted by
<code class="docutils literal notranslate"><span class="pre">explained_variance_</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_components, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.explained_variance_">
<span class="sig-name descname"><span class="pre">explained_variance_</span></span><a class="headerlink" href="#sklearn.decomposition.qPCA.explained_variance_" title="Permalink to this definition">¶</a></dt>
<dd><p>The amount of variance explained by each of the selected components.
The variance estimation uses <cite>n_samples - 1</cite> degrees of freedom.</p>
<p>Equal to n_components largest eigenvalues
of the covariance matrix of X.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_components,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.explained_variance_ratio_">
<span class="sig-name descname"><span class="pre">explained_variance_ratio_</span></span><a class="headerlink" href="#sklearn.decomposition.qPCA.explained_variance_ratio_" title="Permalink to this definition">¶</a></dt>
<dd><p>Percentage of variance explained by each of the selected components.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">n_components</span></code> is not set then all components are stored and the
sum of the ratios is equal to 1.0.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_components,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.singular_values_">
<span class="sig-name descname"><span class="pre">singular_values_</span></span><a class="headerlink" href="#sklearn.decomposition.qPCA.singular_values_" title="Permalink to this definition">¶</a></dt>
<dd><p>The singular values corresponding to each of the selected components.
The singular values are equal to the 2-norms of the <code class="docutils literal notranslate"><span class="pre">n_components</span></code>
variables in the lower-dimensional space.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_components,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.mean_">
<span class="sig-name descname"><span class="pre">mean_</span></span><a class="headerlink" href="#sklearn.decomposition.qPCA.mean_" title="Permalink to this definition">¶</a></dt>
<dd><p>Per-feature empirical mean, estimated from the training set.</p>
<p>Equal to <cite>X.mean(axis=0)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.n_components_">
<span class="sig-name descname"><span class="pre">n_components_</span></span><a class="headerlink" href="#sklearn.decomposition.qPCA.n_components_" title="Permalink to this definition">¶</a></dt>
<dd><p>The estimated number of components. When n_components is set
to ‘mle’ or a number between 0 and 1 (with svd_solver == ‘full’) this
number is estimated from input data. Otherwise it equals the parameter
n_components, or the lesser value of n_features and n_samples
if n_components is None.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.n_features_">
<span class="sig-name descname"><span class="pre">n_features_</span></span><a class="headerlink" href="#sklearn.decomposition.qPCA.n_features_" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of features in the training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.n_samples_">
<span class="sig-name descname"><span class="pre">n_samples_</span></span><a class="headerlink" href="#sklearn.decomposition.qPCA.n_samples_" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of samples in the training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.noise_variance_">
<span class="sig-name descname"><span class="pre">noise_variance_</span></span><a class="headerlink" href="#sklearn.decomposition.qPCA.noise_variance_" title="Permalink to this definition">¶</a></dt>
<dd><p>The estimated noise covariance following the Probabilistic PCA model
from Tipping and Bishop 1999. See “Pattern Recognition and
Machine Learning” by C. Bishop, 12.2.1 p. 574 or
<a class="reference external" href="http://www.miketipping.com/papers/met-mppca.pdf">http://www.miketipping.com/papers/met-mppca.pdf</a>. It is required to
compute the estimated data covariance and score samples.</p>
<p>Equal to the average of (min(n_features, n_samples) - n_components)
smallest eigenvalues of the covariance matrix of X.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">KernelPCA</span></code></dt><dd><p>Kernel Principal Component Analysis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparsePCA</span></code></dt><dd><p>Sparse Principal Component Analysis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">TruncatedSVD</span></code></dt><dd><p>Dimensionality reduction using truncated SVD.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">IncrementalPCA</span></code></dt><dd><p>Incremental Principal Component Analysis.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>For n_components == ‘mle’, this class uses the method from:
<a class="reference external" href="https://tminka.github.io/papers/pca/minka-pca.pdf">Minka, T. P.. “Automatic choice of dimensionality for PCA”.
In NIPS, pp. 598-604</a></p>
<p>Implements the probabilistic PCA model from:
<a class="reference external" href="http://www.miketipping.com/papers/met-mppca.pdf">Tipping, M. E., and Bishop, C. M. (1999). “Probabilistic principal
component analysis”. Journal of the Royal Statistical Society:
Series B (Statistical Methodology), 61(3), 611-622.</a>
via the score and score_samples methods.</p>
<p>For svd_solver == ‘arpack’, refer to <cite>scipy.sparse.linalg.svds</cite>.</p>
<p>For svd_solver == ‘randomized’, see:
<a class="reference external" href="https://doi.org/10.1137/090771806">Halko, N., Martinsson, P. G., and Tropp, J. A. (2011).
“Finding structure with randomness: Probabilistic algorithms for
constructing approximate matrix decompositions”.
SIAM review, 53(2), 217-288.</a>
and also
<a class="reference external" href="https://doi.org/10.1016/j.acha.2010.02.003">Martinsson, P. G., Rokhlin, V., and Tygert, M. (2011).
“A randomized algorithm for the decomposition of matrices”.
Applied and Computational Harmonic Analysis, 30(1), 47-68</a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">PCA(n_components=2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
<span class="go">[0.9924... 0.0075...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">singular_values_</span><span class="p">)</span>
<span class="go">[6.30061... 0.54980...]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">PCA(n_components=2, svd_solver=&#39;full&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
<span class="go">[0.9924... 0.00755...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">singular_values_</span><span class="p">)</span>
<span class="go">[6.30061... 0.54980...]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qpca</span> <span class="o">=</span> <span class="n">qPCA</span><span class="p">(</span><span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="go">qPCA fit with eps and delta error to estimate factor_score, singular values ecc... .</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qpca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">theta_estimate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">eps_theta</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mf">0.70</span><span class="p">,</span><span class="n">estimate_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">delta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">qpca</span><span class="o">.</span><span class="n">estimate_fs_ratio</span><span class="p">)</span>
<span class="go">[1.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">qpca</span><span class="o">.</span><span class="n">estimate_s_values</span><span class="p">)</span>
<span class="go">[1.07791089]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;arpack&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">PCA(n_components=1, svd_solver=&#39;arpack&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
<span class="go">[0.99244...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">singular_values_</span><span class="p">)</span>
<span class="go">[6.30061...]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.condition_number_estimation">
<span class="sig-name descname"><span class="pre">condition_number_estimation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.decomposition.qPCA.condition_number_estimation" title="Permalink to this definition">¶</a></dt>
<dd><p>l = 0
u = 1
n_iterations = int(np.ceil((np.log(self.frob_norm / epsilon))))
tau = (l + u) / 2
for i in range(n_iterations):</p>
<blockquote>
<div><dl>
<dt>theta_from_sv = np.array(</dt><dd><dl class="simple">
<dt>[wrapper_phase_est_arguments(sv) / ((1 / epsilon) + np.pi) for sv in</dt><dd><p><a href="#id1"><span class="problematic" id="id2">self.singular_values_</span></a> / self.frob_norm])</p>
</dd>
</dl>
</dd>
<dt>theta_estimations = [consistent_phase_estimation(omega=theta_, epsilon=epsilon / self.frob_norm,</dt><dd><blockquote>
<div><p>delta=1 - 1 / <a href="#id3"><span class="problematic" id="id4">self.n_features_</span></a>) for</p>
</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">theta_</span></a> in
theta_from_sv]</p>
</dd>
</dl>
<p>est_sing_values = np.array([unwrap_phase_est_arguments(th, eps=1 / epsilon) for th in theta_estimations])
selected_sing_values = self.singular_values_[est_sing_values &lt;= tau]
eta = np.sum(np.square(selected_sing_values)) / (self.frob_norm ** 2)
if eta &gt; 1:</p>
<blockquote>
<div><p>eta = 1</p>
</div></blockquote>
<p>sing_values_reversed_squared = (self.singular_values_[::-1] ** 2) / (self.frob_norm ** 2)
eta_est = amplitude_estimation(theta=eta, epsilon=delta)
k_first = self.singular_values_[::-1][np.where(np.cumsum(sing_values_reversed_squared) &gt;= eta_est)[0][0]]
if eta_est == 1:</p>
<blockquote>
<div><p>u = tau</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>l = tau</p>
</dd>
</dl>
<p>tau = (u + l) / 2</p>
</div></blockquote>
<p>sing_min = self.spectral_norm / k_first</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classic_ret_variance_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantum_retained_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_major</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_minor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_estimate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_computed_qcomponents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_tomography</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs_ratio_estimation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_when_reached_accuracy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incremental_measure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faster_measure_increment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_sv_uniform_distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectral_norm_est</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">condition_number_est</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_least_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.decomposition.qPCA.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the model with X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Training data, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>Ignored</em>) – </p></li>
<li><p><strong>quantum_retained_variance</strong> (<em>bool</em><em>, </em><em>default=False.</em>) – If true it computes the retained variance in the quantum version of the algorithm (Theorem 9 of QADRA)</p></li>
<li><p><strong>eps</strong> (<em>float</em><em>, </em><em>default=0.</em>) – Error to introduce for the singular values estimation.</p></li>
<li><p><strong>theta_major</strong> (<em>float</em><em>, </em><em>default=0.</em>) – Smallest singular values to retain in order to compute the retained variance.</p></li>
<li><p><strong>theta_minor</strong> (<em>float</em><em>, </em><em>default=0.</em>) – Greatest singular values to retain. It is very useful in case one want to extract and estimate the least
singular values: with the right theta_minor value, we are able to select all the estimated singular values
that are less than this value.</p></li>
<li><p><strong>eta</strong> (<em>float</em><em>, </em><em>default=0.</em>) – Used to compute the relative error of the estimated variance. If it is zero,
the retained variance is returned without any error.</p></li>
<li><p><strong>theta_estimate</strong> (<em>bool</em><em>, </em><em>default=False.</em>) – If true compute the estimation of theta using quantum binary search.</p></li>
<li><p><strong>eps_theta</strong> (<em>float</em><em>, </em><em>default=0.</em>) – Error to introduce in the estimation of theta in SVE in quantum binary search.</p></li>
<li><p><strong>p</strong> (<em>float</em><em>, </em><em>default=0.</em>) – Percentage of retained variance to estimate theta.</p></li>
<li><p><strong>estimate_all</strong> (<em>bool</em><em>, </em><em>default=False.</em>) – If true, singular vectors (left and right), singular values and factor scores are estimated.</p></li>
<li><p><strong>delta</strong> (<em>float</em><em>, </em><em>default=0.</em>) – Is the error to insert in the estimation of the singular vectors.</p></li>
<li><p><strong>true_tomography</strong> (<em>bool</em><em>, </em><em>default=True.</em>) – If true means that the quantum estimations are are done with real tomography,
otherwise the estimations are approximated with a Truncated Gaussian Noise.</p></li>
<li><p><strong>fs_ratio_estimation</strong> (<em>bool</em><em>, </em><em>default=False.</em>) – If true, it estimates factor score ratios using SVE.</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>default=0.1.</em>) – Used in the factor score estimation to select the singular values whose respective factor score ratios are
greater than this value.</p></li>
<li><p><strong>norm</strong> (<em>string</em><em>, </em><em>default='L2'.</em>) – <dl class="simple">
<dt>If ‘L2’ (and true_tomography is True):</dt><dd><p>true_tomography is executed with L2-norm guarantees.</p>
</dd>
<dt>If ‘inf’ (and true_tomography is True):</dt><dd><p>true_tomography is executed with Linf-norm guarantees.</p>
</dd>
</dl>
</p></li>
<li><p><strong>stop_when_reached_accuracy</strong> (<em>bool</em><em>, </em><em>default=True.</em>) – If True, the execution of the tomography is stopped when we reach an estimate delta-close in L2-norm
to the true value that we are estimating. Otherwise all the N=36d log(d)/delta**2 measures are performed.</p></li>
<li><p><strong>incremental_measure</strong> (<em>bool</em><em>, </em><em>default=True.</em>) – If True, tomography is performed many times with different number of measures. If False, the routine is
performed once using exactly N=36d log(d)/delta**2 measures.</p></li>
<li><p><strong>faster_measure_increment</strong> (<em>int</em><em>, </em><em>default=0.</em>) – It increments the tomography measures of a specific constant value. It is useful in the case one want to
speed-up the execution of the tomography.</p></li>
<li><p><strong>spectral_norm_est</strong> (<em>bool</em><em>, </em><em>default=False.</em>) – If True, an estimation of the spectral norm of the input matrix is computed.</p></li>
<li><p><strong>estimate_least_k</strong> (<em>bool</em><em>, </em><em>default=False.</em>) – If True, the quantum least singular vectors extractor is executed. In this case it is important to pass a sensible
theta_minor parameter to consider the right singular values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns the instance itself.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantum_retained_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_estimate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_computed_qcomponents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.decomposition.qPCA.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to <cite>X</cite> and <cite>y</cite> with optional parameters <cite>fit_params</cite>
and returns a transformed version of <cite>X</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input samples.</p></li>
<li><p><strong>y</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or </em><em>(</em><em>n_samples</em><em>, </em><em>n_outputs</em><em>)</em><em>,                 </em><em>default=None</em>) – Target values (None for unsupervised transformations).</p></li>
<li><p><strong>**fit_params</strong> (<em>dict</em>) – Additional fit parameters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_new</strong> – Transformed array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray array of shape (n_samples, n_features_new)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_classical_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.decomposition.qPCA.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform data back to its original space.</p>
<p>In other words, return an input X_original whose transform would be X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_components</em><em>)</em>) – New data, where n_samples is the number of samples
and n_components is the number of components.</p></li>
<li><p><strong>use_classical_components</strong> (<em>bool</em><em>, </em><em>default = True.</em>) – See documentation in transform method in qPCA.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>X_original array-like, shape (n_samples, n_features)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If whitening is enabled, inverse_transform will compute the
exact inverse operation, which includes reversing whitening.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.runtime_comparison">
<span class="sig-name descname"><span class="pre">runtime_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saveas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimate_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classic_runtime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'classic'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.decomposition.qPCA.runtime_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that allows to compare classic vs quantum runtime of the algorithm executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_samples</strong> (<em>int value.</em>) – The number of samples that you want to simulate in the runtime measurements.</p></li>
<li><p><strong>n_features</strong> (<em>int value.</em>) – The number of features that you want to simulate in the runtime measurements.</p></li>
<li><p><strong>saveas</strong> (<em>string value.</em>) – Name under which the image will be saved. Specify also the format, otherwise the image will be saved with
the .fig MATLAB format.</p></li>
<li><p><strong>estimate_components</strong> (<em>string value</em><em>, </em><em>default='all'.</em>) – <dl class="simple">
<dt>If ‘all’:</dt><dd><p>It means that you have estimated the left/right singular vectors, the singular values, factor score and
factor score ratios.</p>
</dd>
<dt>If ‘left_sv’:</dt><dd><p>It means that you have estimated the left singular vectors, the singular values, factor score and
factor score ratios.</p>
</dd>
<dt>If ‘right_sv’:</dt><dd><p>It means that you have estimated the right singular vectors, the singular values, factor score and
factor score ratios.</p>
</dd>
</dl>
</p></li>
<li><p><strong>classic_runtime</strong> (<em>string value</em><em>, </em><em>default='classic'.</em>) – <dl class="simple">
<dt>If ‘classic’:</dt><dd><p>It means that you want compare the quantum runtime with the classic runtime version of PCA, that is
O(nm^2) where n are the number of samples and m the number of features.</p>
</dd>
<dt>If ‘rand’:</dt><dd><p>It means that you want compare the quantum runtime with the randomized runtime version of PCA, that is
O(nmk*log(m*eps/eps)) where k are the components retained and eps is an approximation error related to
the relative spectral gap between eigenvalues.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>This functions doesn’t return anything, it just save the runtime comparison plot.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function use the MATLAB engine. This because the MATLAB plots are more visible and clear.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.decomposition.qPCA.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classic_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon_delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantum_representation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'None'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_tomography</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_classical_components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.decomposition.qPCA.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the model with X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Training data, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>classic_transform</strong> (<em>bool</em><em>, </em><em>default=True.</em>) – If true, the classic transform is applied, otherwise quantum transform is applied.</p></li>
<li><p><strong>epsilon_delta</strong> (<em>float</em><em>, </em><em>default=0.</em>) – Error to estimate the matrix (np.sqrt(n_components)*epsilon_delta)</p></li>
<li><p><strong>quantum_representation</strong> (<em>bool</em><em>, </em><em>default=False.</em>) – If true it returns a different quantum representation of the data X, depending on the norm flag.</p></li>
<li><p><strong>norm</strong> (<em>{'est_representation'</em><em>, </em><em>'q_state'</em><em>, </em><em>'None'</em><em>, </em><em>'f_norm'}</em><em>, </em><em>default='None'</em>) – <dl class="simple">
<dt>If est_representation :</dt><dd><p>Estimates the U*Sigma matrix (lemma 13 QADRA)</p>
</dd>
<dt>If q_state :</dt><dd><p>Create and return the quantum state.</p>
</dd>
<dt>If None :</dt><dd><p>return only the estimate matrix with psi error</p>
</dd>
<dt>If f_norm :</dt><dd><p>return only the estimate matrix (with psi error) divided by its f-norm</p>
</dd>
</dl>
</p></li>
<li><p><strong>use_classical_components</strong> (<em>bool</em><em>, </em><em>default=True.</em>) – If True, and classical_transform is False, it computes the classic transformation of the matrix X
and then an error is applied to this new matrix. If False, it computes the trasformation using the
estimated components with a certain error computed using Theorem 11 of QADRA.</p></li>
<li><p><strong>true_tomography</strong> (<em>bool</em><em>, </em><em>default=True.</em>) – If true means that the quantum estimations are done with real tomography,
otherwise the estimations are approximated with a Truncated Gaussian Noise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns the transformed matrix,
otherwise return a dictionary with all the result based on what you want to estimate.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>If classic_transform</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sklearn.QuantumUtility.html" class="btn btn-neutral float-right" title="q_utilities" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sklearn.cluster.html" class="btn btn-neutral float-left" title="q_means" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Tommaso Fioravanti

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>