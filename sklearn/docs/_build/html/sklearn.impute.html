

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sklearn.impute package &mdash; sqlearn  documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> sqlearn
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">sqlearn</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">sqlearn</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>sklearn.impute package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/sklearn.impute.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="sklearn-impute-package">
<h1>sklearn.impute package<a class="headerlink" href="#sklearn-impute-package" title="Permalink to this headline">¶</a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="sklearn.impute.tests.html">sklearn.impute.tests package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="sklearn.impute.tests.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.impute.tests.html#sklearn-impute-tests-test-base-module">sklearn.impute.tests.test_base module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.impute.tests.html#sklearn-impute-tests-test-common-module">sklearn.impute.tests.test_common module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.impute.tests.html#sklearn-impute-tests-test-impute-module">sklearn.impute.tests.test_impute module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.impute.tests.html#sklearn-impute-tests-test-knn-module">sklearn.impute.tests.test_knn module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sklearn.impute.tests.html#module-sklearn.impute.tests">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="module-sklearn.impute">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-sklearn.impute" title="Permalink to this headline">¶</a></h2>
<p>Transformers for missing value imputation</p>
<dl class="py class">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sklearn.impute.</span></span><span class="sig-name descname"><span class="pre">IterativeImputer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_posterior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_nearest_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imputation_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ascending'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_complete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_indicator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.IterativeImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.impute._base._BaseImputer</span></code></p>
<p>Multivariate imputer that estimates each feature from all the others.</p>
<p>A strategy for imputing missing values by modeling each feature with
missing values as a function of other features in a round-robin fashion.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This estimator is still <strong>experimental</strong> for now: the predictions
and the API might change without any deprecation cycle. To use it,
you need to explicitly import <code class="docutils literal notranslate"><span class="pre">enable_iterative_imputer</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># explicitly require this experimental feature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.experimental</span> <span class="kn">import</span> <span class="n">enable_iterative_imputer</span>  <span class="c1"># noqa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># now you can import normally from sklearn.impute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">IterativeImputer</span>
</pre></div>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> (<em>estimator object</em><em>, </em><em>default=BayesianRidge</em><em>(</em><em>)</em>) – The estimator to use at each step of the round-robin imputation.
If <code class="docutils literal notranslate"><span class="pre">sample_posterior</span></code> is True, the estimator must support
<code class="docutils literal notranslate"><span class="pre">return_std</span></code> in its <code class="docutils literal notranslate"><span class="pre">predict</span></code> method.</p></li>
<li><p><strong>missing_values</strong> (<em>int</em><em>, </em><em>np.nan</em><em>, </em><em>default=np.nan</em>) – The placeholder for the missing values. All occurrences of
<cite>missing_values</cite> will be imputed. For pandas’ dataframes with
nullable integer dtypes with missing values, <cite>missing_values</cite>
should be set to <cite>np.nan</cite>, since <cite>pd.NA</cite> will be converted to <cite>np.nan</cite>.</p></li>
<li><p><strong>sample_posterior</strong> (<em>boolean</em><em>, </em><em>default=False</em>) – Whether to sample from the (Gaussian) predictive posterior of the
fitted estimator for each imputation. Estimator must support
<code class="docutils literal notranslate"><span class="pre">return_std</span></code> in its <code class="docutils literal notranslate"><span class="pre">predict</span></code> method if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. Set to
<code class="docutils literal notranslate"><span class="pre">True</span></code> if using <code class="docutils literal notranslate"><span class="pre">IterativeImputer</span></code> for multiple imputations.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>default=10</em>) – Maximum number of imputation rounds to perform before returning the
imputations computed during the final round. A round is a single
imputation of each feature with missing values. The stopping criterion
is met once <cite>max(abs(X_t - X_{t-1}))/max(abs(X[known_vals])) &lt; tol</cite>,
where <cite>X_t</cite> is <cite>X</cite> at iteration <cite>t</cite>. Note that early stopping is only
applied if <code class="docutils literal notranslate"><span class="pre">sample_posterior=False</span></code>.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>default=1e-3</em>) – Tolerance of the stopping condition.</p></li>
<li><p><strong>n_nearest_features</strong> (<em>int</em><em>, </em><em>default=None</em>) – Number of other features to use to estimate the missing values of
each feature column. Nearness between features is measured using
the absolute correlation coefficient between each feature pair (after
initial imputation). To ensure coverage of features throughout the
imputation process, the neighbor features are not necessarily nearest,
but are drawn with probability proportional to correlation for each
imputed target feature. Can provide significant speed-up when the
number of features is huge. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, all features will be used.</p></li>
<li><p><strong>initial_strategy</strong> (<em>str</em><em>, </em><em>default='mean'</em>) – Which strategy to use to initialize the missing values. Same as the
<code class="docutils literal notranslate"><span class="pre">strategy</span></code> parameter in <a class="reference internal" href="#sklearn.impute.SimpleImputer" title="sklearn.impute.SimpleImputer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleImputer</span></code></a>
Valid values: {“mean”, “median”, “most_frequent”, or “constant”}.</p></li>
<li><p><strong>imputation_order</strong> (<em>str</em><em>, </em><em>default='ascending'</em>) – <p>The order in which the features will be imputed. Possible values:</p>
<dl class="simple">
<dt>”ascending”</dt><dd><p>From features with fewest missing values to most.</p>
</dd>
<dt>”descending”</dt><dd><p>From features with most missing values to fewest.</p>
</dd>
<dt>”roman”</dt><dd><p>Left to right.</p>
</dd>
<dt>”arabic”</dt><dd><p>Right to left.</p>
</dd>
<dt>”random”</dt><dd><p>A random order for each round.</p>
</dd>
</dl>
</p></li>
<li><p><strong>skip_complete</strong> (<em>boolean</em><em>, </em><em>default=False</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> then features with missing values during <code class="docutils literal notranslate"><span class="pre">transform</span></code>
which did not have any missing values during <code class="docutils literal notranslate"><span class="pre">fit</span></code> will be imputed
with the initial imputation method only. Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> if you have
many features with no missing values at both <code class="docutils literal notranslate"><span class="pre">fit</span></code> and <code class="docutils literal notranslate"><span class="pre">transform</span></code>
time to save compute.</p></li>
<li><p><strong>min_value</strong> (<em>float</em><em> or </em><em>array-like of shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em><em>, </em><em>default=-np.inf</em>) – <p>Minimum possible imputed value. Broadcast to shape (n_features,) if
scalar. If array-like, expects shape (n_features,), one min value for
each feature. The default is <cite>-np.inf</cite>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23: </span>Added support for array-like.</p>
</div>
</p></li>
<li><p><strong>max_value</strong> (<em>float</em><em> or </em><em>array-like of shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em><em>, </em><em>default=np.inf</em>) – <p>Maximum possible imputed value. Broadcast to shape (n_features,) if
scalar. If array-like, expects shape (n_features,), one max value for
each feature. The default is <cite>np.inf</cite>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23: </span>Added support for array-like.</p>
</div>
</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>default=0</em>) – Verbosity flag, controls the debug messages that are issued
as functions are evaluated. The higher, the more verbose. Can be 0, 1,
or 2.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) – The seed of the pseudo random number generator to use. Randomizes
selection of estimator features if n_nearest_features is not None, the
<code class="docutils literal notranslate"><span class="pre">imputation_order</span></code> if <code class="docutils literal notranslate"><span class="pre">random</span></code>, and the sampling from posterior if
<code class="docutils literal notranslate"><span class="pre">sample_posterior</span></code> is True. Use an integer for determinism.
See <span class="xref std std-term">the Glossary</span>.</p></li>
<li><p><strong>add_indicator</strong> (<em>boolean</em><em>, </em><em>default=False</em>) – If True, a <a class="reference internal" href="#sklearn.impute.MissingIndicator" title="sklearn.impute.MissingIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingIndicator</span></code></a> transform will stack onto output
of the imputer’s transform. This allows a predictive estimator
to account for missingness despite imputation. If a feature has no
missing values at fit/train time, the feature won’t appear on
the missing indicator even if there are missing values at
transform/test time.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer.initial_imputer_">
<span class="sig-name descname"><span class="pre">initial_imputer_</span></span><a class="headerlink" href="#sklearn.impute.IterativeImputer.initial_imputer_" title="Permalink to this definition">¶</a></dt>
<dd><p>Imputer used to initialize the missing values.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>object of type <a class="reference internal" href="#sklearn.impute.SimpleImputer" title="sklearn.impute.SimpleImputer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleImputer</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer.imputation_sequence_">
<span class="sig-name descname"><span class="pre">imputation_sequence_</span></span><a class="headerlink" href="#sklearn.impute.IterativeImputer.imputation_sequence_" title="Permalink to this definition">¶</a></dt>
<dd><p>Each tuple has <code class="docutils literal notranslate"><span class="pre">(feat_idx,</span> <span class="pre">neighbor_feat_idx,</span> <span class="pre">estimator)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">feat_idx</span></code> is the current feature to be imputed,
<code class="docutils literal notranslate"><span class="pre">neighbor_feat_idx</span></code> is the array of other features used to impute the
current feature, and <code class="docutils literal notranslate"><span class="pre">estimator</span></code> is the trained estimator used for
the imputation. Length is <code class="docutils literal notranslate"><span class="pre">self.n_features_with_missing_</span> <span class="pre">*</span>
<span class="pre">self.n_iter_</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of tuples</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer.n_iter_">
<span class="sig-name descname"><span class="pre">n_iter_</span></span><a class="headerlink" href="#sklearn.impute.IterativeImputer.n_iter_" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iteration rounds that occurred. Will be less than
<code class="docutils literal notranslate"><span class="pre">self.max_iter</span></code> if early stopping criterion was reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer.n_features_with_missing_">
<span class="sig-name descname"><span class="pre">n_features_with_missing_</span></span><a class="headerlink" href="#sklearn.impute.IterativeImputer.n_features_with_missing_" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of features with missing values.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer.indicator_">
<span class="sig-name descname"><span class="pre">indicator_</span></span><a class="headerlink" href="#sklearn.impute.IterativeImputer.indicator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicator used to add binary indicators for missing values.
<code class="docutils literal notranslate"><span class="pre">None</span></code> if add_indicator is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#sklearn.impute.MissingIndicator" title="sklearn.impute.MissingIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingIndicator</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer.random_state_">
<span class="sig-name descname"><span class="pre">random_state_</span></span><a class="headerlink" href="#sklearn.impute.IterativeImputer.random_state_" title="Permalink to this definition">¶</a></dt>
<dd><p>RandomState instance that is generated either from a seed, the random
number generator or by <cite>np.random</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>RandomState instance</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sklearn.impute.SimpleImputer" title="sklearn.impute.SimpleImputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SimpleImputer</span></code></a></dt><dd><p>Univariate imputation of missing values.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.experimental</span> <span class="kn">import</span> <span class="n">enable_iterative_imputer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">IterativeImputer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp_mean</span> <span class="o">=</span> <span class="n">IterativeImputer</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp_mean</span><span class="o">.</span><span class="n">fit</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="go">IterativeImputer(random_state=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">9</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp_mean</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 6.9584...,  2.       ,  3.        ],</span>
<span class="go">       [ 4.       ,  2.6000...,  6.        ],</span>
<span class="go">       [10.       ,  4.9999...,  9.        ]])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>To support imputation in inductive mode we store each feature’s estimator
during the <code class="docutils literal notranslate"><span class="pre">fit</span></code> phase, and predict without refitting (in order) during
the <code class="docutils literal notranslate"><span class="pre">transform</span></code> phase.</p>
<p>Features which contain all missing values at <code class="docutils literal notranslate"><span class="pre">fit</span></code> are discarded upon
<code class="docutils literal notranslate"><span class="pre">transform</span></code>.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://www.jstatsoft.org/article/view/v045i03">Stef van Buuren, Karin Groothuis-Oudshoorn (2011). “mice:
Multivariate Imputation by Chained Equations in R”. Journal of
Statistical Software 45: 1-67.</a></p>
</dd>
<dt class="label" id="id2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://www.jstor.org/stable/2984099">S. F. Buck, (1960). “A Method of Estimation of Missing Values in
Multivariate Data Suitable for use with an Electronic Computer”.
Journal of the Royal Statistical Society 22(2): 302-306.</a></p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.IterativeImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the imputer on X and return self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data, where “n_samples” is the number of samples and
“n_features” is the number of features.</p></li>
<li><p><strong>y</strong> (<em>ignored</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.IterativeImputer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the imputer on X and return the transformed X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data, where “n_samples” is the number of samples and
“n_features” is the number of features.</p></li>
<li><p><strong>y</strong> (<em>ignored.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – The imputed input data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.IterativeImputer.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.IterativeImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Imputes all missing values in X.</p>
<p>Note that this is stochastic, and that if random_state is not fixed,
repeated calls, or permuted input, will yield different results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The input data to complete.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – The imputed input data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sklearn.impute.KNNImputer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sklearn.impute.</span></span><span class="sig-name descname"><span class="pre">KNNImputer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'uniform'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nan_euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_indicator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.KNNImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.impute._base._BaseImputer</span></code></p>
<p>Imputation for completing missing values using k-Nearest Neighbors.</p>
<p>Each sample’s missing values are imputed using the mean value from
<cite>n_neighbors</cite> nearest neighbors found in the training set. Two samples are
close if the features that neither is missing are close.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.22.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>missing_values</strong> (<em>int</em><em>, </em><em>float</em><em>, </em><em>str</em><em>, </em><em>np.nan</em><em> or </em><em>None</em><em>, </em><em>default=np.nan</em>) – The placeholder for the missing values. All occurrences of
<cite>missing_values</cite> will be imputed. For pandas’ dataframes with
nullable integer dtypes with missing values, <cite>missing_values</cite>
should be set to np.nan, since <cite>pd.NA</cite> will be converted to np.nan.</p></li>
<li><p><strong>n_neighbors</strong> (<em>int</em><em>, </em><em>default=5</em>) – Number of neighboring samples to use for imputation.</p></li>
<li><p><strong>weights</strong> (<em>{'uniform'</em><em>, </em><em>'distance'}</em><em> or </em><em>callable</em><em>, </em><em>default='uniform'</em>) – <p>Weight function used in prediction.  Possible values:</p>
<ul>
<li><p>’uniform’ : uniform weights. All points in each neighborhood are
weighted equally.</p></li>
<li><p>’distance’ : weight points by the inverse of their distance.
in this case, closer neighbors of a query point will have a
greater influence than neighbors which are further away.</p></li>
<li><p>callable : a user-defined function which accepts an
array of distances, and returns an array of the same shape
containing the weights.</p></li>
</ul>
</p></li>
<li><p><strong>metric</strong> (<em>{'nan_euclidean'}</em><em> or </em><em>callable</em><em>, </em><em>default='nan_euclidean'</em>) – <p>Distance metric for searching neighbors. Possible values:</p>
<ul>
<li><p>’nan_euclidean’</p></li>
<li><p>callable : a user-defined function which conforms to the definition
of <code class="docutils literal notranslate"><span class="pre">_pairwise_callable(X,</span> <span class="pre">Y,</span> <span class="pre">metric,</span> <span class="pre">**kwds)</span></code>. The function
accepts two arrays, X and Y, and a <cite>missing_values</cite> keyword in
<cite>kwds</cite> and returns a scalar distance value.</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True, a copy of X will be created. If False, imputation will
be done in-place whenever possible.</p></li>
<li><p><strong>add_indicator</strong> (<em>bool</em><em>, </em><em>default=False</em>) – If True, a <a class="reference internal" href="#sklearn.impute.MissingIndicator" title="sklearn.impute.MissingIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingIndicator</span></code></a> transform will stack onto the
output of the imputer’s transform. This allows a predictive estimator
to account for missingness despite imputation. If a feature has no
missing values at fit/train time, the feature won’t appear on the
missing indicator even if there are missing values at transform/test
time.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.KNNImputer.indicator_">
<span class="sig-name descname"><span class="pre">indicator_</span></span><a class="headerlink" href="#sklearn.impute.KNNImputer.indicator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicator used to add binary indicators for missing values.
<code class="docutils literal notranslate"><span class="pre">None</span></code> if add_indicator is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#sklearn.impute.MissingIndicator" title="sklearn.impute.MissingIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingIndicator</span></code></a></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<ul class="simple">
<li><p>Olga Troyanskaya, Michael Cantor, Gavin Sherlock, Pat Brown, Trevor
Hastie, Robert Tibshirani, David Botstein and Russ B. Altman, Missing
value estimation methods for DNA microarrays, BIOINFORMATICS Vol. 17
no. 6, 2001 Pages 520-525.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">KNNImputer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imputer</span> <span class="o">=</span> <span class="n">KNNImputer</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[1. , 2. , 4. ],</span>
<span class="go">       [3. , 4. , 3. ],</span>
<span class="go">       [5.5, 6. , 5. ],</span>
<span class="go">       [8. , 8. , 7. ]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.KNNImputer.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.KNNImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the imputer on X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like shape of</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data, where <cite>n_samples</cite> is the number of samples and
<cite>n_features</cite> is the number of features.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.KNNImputer.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.KNNImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Impute all missing values in X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The input data to complete.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X</strong> – The imputed dataset. <cite>n_output_features</cite> is the number of features
that is not always missing during <cite>fit</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like of shape (n_samples, n_output_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sklearn.impute.MissingIndicator">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sklearn.impute.</span></span><span class="sig-name descname"><span class="pre">MissingIndicator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'missing-only'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_on_new</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.MissingIndicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Binary indicators for missing values.</p>
<p>Note that this component typically should not be used in a vanilla
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code> consisting of transformers and a classifier, but rather
could be added using a <code class="xref py py-class docutils literal notranslate"><span class="pre">FeatureUnion</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnTransformer</span></code>.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>missing_values</strong> (<em>int</em><em>, </em><em>float</em><em>, </em><em>string</em><em>, </em><em>np.nan</em><em> or </em><em>None</em><em>, </em><em>default=np.nan</em>) – The placeholder for the missing values. All occurrences of
<cite>missing_values</cite> will be imputed. For pandas’ dataframes with
nullable integer dtypes with missing values, <cite>missing_values</cite>
should be set to <cite>np.nan</cite>, since <cite>pd.NA</cite> will be converted to <cite>np.nan</cite>.</p></li>
<li><p><strong>features</strong> (<em>{'missing-only'</em><em>, </em><em>'all'}</em><em>, </em><em>default='missing-only'</em>) – <p>Whether the imputer mask should represent all or a subset of
features.</p>
<ul>
<li><p>If ‘missing-only’ (default), the imputer mask will only represent
features containing missing values during fit time.</p></li>
<li><p>If ‘all’, the imputer mask will represent all features.</p></li>
</ul>
</p></li>
<li><p><strong>sparse</strong> (<em>bool</em><em> or </em><em>'auto'</em><em>, </em><em>default='auto'</em>) – <p>Whether the imputer mask format should be sparse or dense.</p>
<ul>
<li><p>If ‘auto’ (default), the imputer mask will be of same type as
input.</p></li>
<li><p>If True, the imputer mask will be a sparse matrix.</p></li>
<li><p>If False, the imputer mask will be a numpy array.</p></li>
</ul>
</p></li>
<li><p><strong>error_on_new</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True, transform will raise an error when there are features with
missing values in transform that have no missing values in fit. This is
applicable only when <cite>features=’missing-only’</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.MissingIndicator.features_">
<span class="sig-name descname"><span class="pre">features_</span></span><a class="headerlink" href="#sklearn.impute.MissingIndicator.features_" title="Permalink to this definition">¶</a></dt>
<dd><p>The features indices which will be returned when calling <code class="docutils literal notranslate"><span class="pre">transform</span></code>.
They are computed during <code class="docutils literal notranslate"><span class="pre">fit</span></code>. For <code class="docutils literal notranslate"><span class="pre">features='all'</span></code>, it is
to <code class="docutils literal notranslate"><span class="pre">range(n_features)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, shape (n_missing_features,) or (n_features,)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">MissingIndicator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indicator</span> <span class="o">=</span> <span class="n">MissingIndicator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indicator</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X1</span><span class="p">)</span>
<span class="go">MissingIndicator()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2_tr</span> <span class="o">=</span> <span class="n">indicator</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2_tr</span>
<span class="go">array([[False,  True],</span>
<span class="go">       [ True, False],</span>
<span class="go">       [False, False]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.MissingIndicator.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.MissingIndicator.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transformer on X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data, where <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> is the number of samples and
<code class="docutils literal notranslate"><span class="pre">n_features</span></code> is the number of features.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.MissingIndicator.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.MissingIndicator.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate missing values indicator for X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The input data to complete.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – The missing indicator for input data. The data type of <code class="docutils literal notranslate"><span class="pre">Xt</span></code>
will be boolean.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{ndarray or sparse matrix}, shape (n_samples, n_features)         or (n_samples, n_features_with_missing)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.MissingIndicator.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.MissingIndicator.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate missing values indicator for X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The input data to complete.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – The missing indicator for input data. The data type of <code class="docutils literal notranslate"><span class="pre">Xt</span></code>
will be boolean.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{ndarray or sparse matrix}, shape (n_samples, n_features)         or (n_samples, n_features_with_missing)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sklearn.impute.SimpleImputer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sklearn.impute.</span></span><span class="sig-name descname"><span class="pre">SimpleImputer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_indicator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.SimpleImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.impute._base._BaseImputer</span></code></p>
<p>Imputation transformer for completing missing values.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span><cite>SimpleImputer</cite> replaces the previous <cite>sklearn.preprocessing.Imputer</cite>
estimator which is now removed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>missing_values</strong> (<em>int</em><em>, </em><em>float</em><em>, </em><em>str</em><em>, </em><em>np.nan</em><em> or </em><em>None</em><em>, </em><em>default=np.nan</em>) – The placeholder for the missing values. All occurrences of
<cite>missing_values</cite> will be imputed. For pandas’ dataframes with
nullable integer dtypes with missing values, <cite>missing_values</cite>
should be set to <cite>np.nan</cite>, since <cite>pd.NA</cite> will be converted to <cite>np.nan</cite>.</p></li>
<li><p><strong>strategy</strong> (<em>string</em><em>, </em><em>default='mean'</em>) – <p>The imputation strategy.</p>
<ul>
<li><p>If “mean”, then replace missing values using the mean along
each column. Can only be used with numeric data.</p></li>
<li><p>If “median”, then replace missing values using the median along
each column. Can only be used with numeric data.</p></li>
<li><p>If “most_frequent”, then replace missing using the most frequent
value along each column. Can be used with strings or numeric data.
If there is more than one such value, only the smallest is returned.</p></li>
<li><p>If “constant”, then replace missing values with fill_value. Can be
used with strings or numeric data.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span>strategy=”constant” for fixed value imputation.</p>
</div>
</p></li>
<li><p><strong>fill_value</strong> (<em>string</em><em> or </em><em>numerical value</em><em>, </em><em>default=None</em>) – When strategy == “constant”, fill_value is used to replace all
occurrences of missing_values.
If left to the default, fill_value will be 0 when imputing numerical
data and “missing_value” for strings or object data types.</p></li>
<li><p><strong>verbose</strong> (<em>integer</em><em>, </em><em>default=0</em>) – Controls the verbosity of the imputer.</p></li>
<li><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>default=True</em>) – <p>If True, a copy of X will be created. If False, imputation will
be done in-place whenever possible. Note that, in the following cases,
a new copy will always be made, even if <cite>copy=False</cite>:</p>
<ul>
<li><p>If X is not an array of floating values;</p></li>
<li><p>If X is encoded as a CSR matrix;</p></li>
<li><p>If add_indicator=True.</p></li>
</ul>
</p></li>
<li><p><strong>add_indicator</strong> (<em>boolean</em><em>, </em><em>default=False</em>) – If True, a <a class="reference internal" href="#sklearn.impute.MissingIndicator" title="sklearn.impute.MissingIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingIndicator</span></code></a> transform will stack onto output
of the imputer’s transform. This allows a predictive estimator
to account for missingness despite imputation. If a feature has no
missing values at fit/train time, the feature won’t appear on
the missing indicator even if there are missing values at
transform/test time.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.SimpleImputer.statistics_">
<span class="sig-name descname"><span class="pre">statistics_</span></span><a class="headerlink" href="#sklearn.impute.SimpleImputer.statistics_" title="Permalink to this definition">¶</a></dt>
<dd><p>The imputation fill value for each feature.
Computing statistics can result in <cite>np.nan</cite> values.
During <a class="reference internal" href="#sklearn.impute.SimpleImputer.transform" title="sklearn.impute.SimpleImputer.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a>, features corresponding to <cite>np.nan</cite>
statistics will be discarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sklearn.impute.SimpleImputer.indicator_">
<span class="sig-name descname"><span class="pre">indicator_</span></span><a class="headerlink" href="#sklearn.impute.SimpleImputer.indicator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicator used to add binary indicators for missing values.
<code class="docutils literal notranslate"><span class="pre">None</span></code> if add_indicator is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#sklearn.impute.MissingIndicator" title="sklearn.impute.MissingIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingIndicator</span></code></a></p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sklearn.impute.IterativeImputer" title="sklearn.impute.IterativeImputer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IterativeImputer</span></code></a></dt><dd><p>Multivariate imputation of missing values.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">SimpleImputer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp_mean</span> <span class="o">=</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp_mean</span><span class="o">.</span><span class="n">fit</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="go">SimpleImputer()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">9</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">imp_mean</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="go">[[ 7.   2.   3. ]</span>
<span class="go"> [ 4.   3.5  6. ]</span>
<span class="go"> [10.   3.5  9. ]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Columns which only contained missing values at <a class="reference internal" href="#sklearn.impute.SimpleImputer.fit" title="sklearn.impute.SimpleImputer.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> are discarded
upon <a class="reference internal" href="#sklearn.impute.SimpleImputer.transform" title="sklearn.impute.SimpleImputer.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a> if strategy is not “constant”.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.SimpleImputer.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.SimpleImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the imputer on X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data, where <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> is the number of samples and
<code class="docutils literal notranslate"><span class="pre">n_features</span></code> is the number of features.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#sklearn.impute.SimpleImputer" title="sklearn.impute.SimpleImputer">SimpleImputer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.SimpleImputer.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.SimpleImputer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<p>Inverts the <cite>transform</cite> operation performed on an array.
This operation can only be performed after <a class="reference internal" href="#sklearn.impute.SimpleImputer" title="sklearn.impute.SimpleImputer"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleImputer</span></code></a> is
instantiated with <cite>add_indicator=True</cite>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">inverse_transform</span></code> can only invert the transform in
features that have binary indicators for missing values. If a feature
has no missing values at <code class="docutils literal notranslate"><span class="pre">fit</span></code> time, the feature won’t have a binary
indicator, and the imputation done at <code class="docutils literal notranslate"><span class="pre">transform</span></code> time won’t be
inverted.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like of shape</em><em>                 (</em><em>n_samples</em><em>, </em><em>n_features + n_features_missing_indicator</em><em>)</em>) – The imputed data to be reverted to original data. It has to be
an augmented array of imputed data and the missing indicator mask.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_original</strong> – The original X with missing values as it was prior
to imputation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sklearn.impute.SimpleImputer.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sklearn.impute.SimpleImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Impute all missing values in X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The input data to complete.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Tommaso Fioravanti

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>